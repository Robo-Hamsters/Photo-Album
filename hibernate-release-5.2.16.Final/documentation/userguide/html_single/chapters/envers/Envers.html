<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="UTF-8">
<!--[if IE]><meta http-equiv="X-UA-Compatible" content="IE=edge"><![endif]-->
<meta name="viewport" content="width=device-width, initial-scale=1.0">
<meta name="generator" content="Asciidoctor 1.5.2">
<title>Envers</title>
<link rel="stylesheet" href="./css/hibernate.css">
<link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/4.2.0/css/font-awesome.min.css">
<link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/prettify/r298/prettify.min.css">
<script src="https://cdnjs.cloudflare.com/ajax/libs/prettify/r298/prettify.min.js"></script>
<script>document.addEventListener('DOMContentLoaded', prettyPrint)</script>
</head>
<body class="article">
<div id="header">
</div>
<div id="content">
<div class="sect1">
<h2 id="envers">Envers</h2>
<div class="sectionbody">
<div class="sect2">
<h3 id="envers-basics">Basics</h3>
<div class="paragraph">
<p>To audit changes that are performed on an entity, you only need two things:</p>
</div>
<div class="ulist">
<ul>
<li>
<p>the <code>hibernate-envers</code> jar on the classpath,</p>
</li>
<li>
<p>an <code>@Audited</code> annotation on the entity.</p>
</li>
</ul>
</div>
<div class="admonitionblock important">
<table>
<tr>
<td class="icon">
<i class="fa icon-important" title="Important"></i>
</td>
<td class="content">
<div class="paragraph">
<p>Unlike in previous versions, you no longer need to specify listeners in the Hibernate configuration file.
Just putting the Envers jar on the classpath is enough because listeners will be registered automatically.</p>
</div>
</td>
</tr>
</table>
</div>
<div class="paragraph">
<p>And that&#8217;s all.
You can create, modify and delete the entities as always.</p>
</div>
<div class="paragraph">
<p>If you look at the generated schema for your entities, or at the data persisted by Hibernate, you will notice that there are no changes.
However, for each audited entity, a new table is introduced - <code>entity_table_AUD</code>, which stores the historical data, whenever you commit a transaction.</p>
</div>
<div class="admonitionblock note">
<table>
<tr>
<td class="icon">
<i class="fa icon-note" title="Note"></i>
</td>
<td class="content">
<div class="paragraph">
<p>Envers automatically creates audit tables if <code>hibernate.hbm2ddl.auto</code> option is set to <code>create</code>, <code>create-drop</code> or <code>update</code>.
Appropriate DDL statements can also be generated with an Ant task in <a href="#envers-generateschema">Generating Envers schema with Hibernate hbm2ddl tool</a>.</p>
</div>
</td>
</tr>
</table>
</div>
<div class="paragraph">
<p>Considering we have a <code>Customer</code> entity, when annotating it with the <code>Audited</code> annotation,
Hibernate is going to generate the following tables using the <code>hibernate.hbm2ddl.auto</code> schema tool:</p>
</div>
<div id="envers-audited-mapping-example" class="exampleblock">
<div class="title">Example 1. Basic Envers entity mapping</div>
<div class="content">
<div class="listingblock">
<div class="content">
<pre class="prettyprint highlight"><code class="language-JAVA" data-lang="JAVA">@Audited
@Entity(name = "Customer")
public static class Customer {

    @Id
    private Long id;

    private String firstName;

    private String lastName;

    @Temporal( TemporalType.TIMESTAMP )
    @Column(name = "created_on")
    @CreationTimestamp
    private Date createdOn;

    //Getters and setters are omitted for brevity

}</code></pre>
</div>
</div>
<div class="listingblock">
<div class="content">
<pre class="prettyprint highlight"><code class="language-SQL" data-lang="SQL">create table Customer (
    id bigint not null,
    created_on timestamp,
    firstName varchar(255),
    lastName varchar(255),
    primary key (id)
)

create table Customer_AUD (
    id bigint not null,
    REV integer not null,
    REVTYPE tinyint,
    created_on timestamp,
    firstName varchar(255),
    lastName varchar(255),
    primary key (id, REV)
)

create table REVINFO (
    REV integer generated by default as identity,
    REVTSTMP bigint,
    primary key (REV)
)

alter table Customer_AUD
   add constraint FK5ecvi1a0ykunrriib7j28vpdj
   foreign key (REV)
   references REVINFO</code></pre>
</div>
</div>
</div>
</div>
<div class="paragraph">
<p>Instead of annotating the whole class and auditing all properties, you can annotate only some persistent properties with <code>@Audited</code>.
This will cause only these properties to be audited.</p>
</div>
<div class="paragraph">
<p>Now, considering the previous <code>Customer</code> entity,
let&#8217;s see how Envers auditing works when inserting, updating, and deleting the entity in question.</p>
</div>
<div id="envers-audited-insert-example" class="exampleblock">
<div class="title">Example 2. Auditing the entity <code>INSERT</code> operation</div>
<div class="content">
<div class="listingblock">
<div class="content">
<pre class="prettyprint highlight"><code class="language-JAVA" data-lang="JAVA">Customer customer = new Customer();
customer.setId( 1L );
customer.setFirstName( "John" );
customer.setLastName( "Doe" );

entityManager.persist( customer );</code></pre>
</div>
</div>
<div class="listingblock">
<div class="content">
<pre class="prettyprint highlight"><code class="language-SQL" data-lang="SQL">insert
into
    Customer
    (created_on, firstName, lastName, id)
values
    (?, ?, ?, ?)

-- binding parameter [1] as [TIMESTAMP] - [Mon Jul 24 17:21:32 EEST 2017]
-- binding parameter [2] as [VARCHAR]   - [John]
-- binding parameter [3] as [VARCHAR]   - [Doe]
-- binding parameter [4] as [BIGINT]    - [1]

insert
into
    REVINFO
    (REV, REVTSTMP)
values
    (?, ?)

-- binding parameter [1] as [BIGINT]    - [1]
-- binding parameter [2] as [BIGINT]    - [1500906092803]

insert
into
    Customer_AUD
    (REVTYPE, created_on, firstName, lastName, id, REV)
values
    (?, ?, ?, ?, ?, ?)

-- binding parameter [1] as [INTEGER]   - [0]
-- binding parameter [2] as [TIMESTAMP] - [Mon Jul 24 17:21:32 EEST 2017]
-- binding parameter [3] as [VARCHAR]   - [John]
-- binding parameter [4] as [VARCHAR]   - [Doe]
-- binding parameter [5] as [BIGINT]    - [1]
-- binding parameter [6] as [INTEGER]   - [1]</code></pre>
</div>
</div>
</div>
</div>
<div id="envers-audited-update-example" class="exampleblock">
<div class="title">Example 3. Auditing the entity <code>UPDATE</code> operation</div>
<div class="content">
<div class="listingblock">
<div class="content">
<pre class="prettyprint highlight"><code class="language-JAVA" data-lang="JAVA">Customer customer = entityManager.find( Customer.class, 1L );
customer.setLastName( "Doe Jr." );</code></pre>
</div>
</div>
<div class="listingblock">
<div class="content">
<pre class="prettyprint highlight"><code class="language-SQL" data-lang="SQL">update
    Customer
set
    created_on=?,
    firstName=?,
    lastName=?
where
    id=?

-- binding parameter [1] as [TIMESTAMP] - [2017-07-24 17:21:32.757]
-- binding parameter [2] as [VARCHAR]   - [John]
-- binding parameter [3] as [VARCHAR]   - [Doe Jr.]
-- binding parameter [4] as [BIGINT]    - [1]

insert
into
    REVINFO
    (REV, REVTSTMP)
values
    (?, ?)

-- binding parameter [1] as [BIGINT]    - [2]
-- binding parameter [2] as [BIGINT]    - [1500906092853]

insert
into
    Customer_AUD
    (REVTYPE, created_on, firstName, lastName, id, REV)
values
    (?, ?, ?, ?, ?, ?)

-- binding parameter [1] as [INTEGER]   - [1]
-- binding parameter [2] as [TIMESTAMP] - [2017-07-24 17:21:32.757]
-- binding parameter [3] as [VARCHAR]   - [John]
-- binding parameter [4] as [VARCHAR]   - [Doe Jr.]
-- binding parameter [5] as [BIGINT]    - [1]
-- binding parameter [6] as [INTEGER]   - [2]</code></pre>
</div>
</div>
</div>
</div>
<div id="envers-audited-delete-example" class="exampleblock">
<div class="title">Example 4. Auditing the entity <code>DELETE</code> operation</div>
<div class="content">
<div class="listingblock">
<div class="content">
<pre class="prettyprint highlight"><code class="language-JAVA" data-lang="JAVA">Customer customer = entityManager.getReference( Customer.class, 1L );
entityManager.remove( customer );</code></pre>
</div>
</div>
<div class="listingblock">
<div class="content">
<pre class="prettyprint highlight"><code class="language-SQL" data-lang="SQL">delete
from
    Customer
where
    id = ?

-- binding parameter [1] as [BIGINT]    - [1]

insert
into
    REVINFO
    (REV, REVTSTMP)
values
    (?, ?)

-- binding parameter [1] as [BIGINT]    - [3]
-- binding parameter [2] as [BIGINT]    - [1500906092876]

insert
into
    Customer_AUD
    (REVTYPE, created_on, firstName, lastName, id, REV)
values
    (?, ?, ?, ?, ?, ?)

-- binding parameter [1] as [INTEGER]   - [2]
-- binding parameter [2] as [TIMESTAMP] - [null]
-- binding parameter [3] as [VARCHAR]   - [null]
-- binding parameter [4] as [VARCHAR]   - [null]
-- binding parameter [5] as [BIGINT]    - [1]
-- binding parameter [6] as [INTEGER]   - [3]</code></pre>
</div>
</div>
</div>
</div>
<div class="paragraph">
<p>The <code>REVTYPE</code> column value is taken from the <a href="https://docs.jboss.org/hibernate/orm/5.2/javadocs/org/hibernate/envers/RevisionType.html"><code>RevisionType</code></a> Enum.</p>
</div>
<table id="envers-revtype-column" class="tableblock frame-all grid-all spread">
<caption class="title">Table 1. <code>REVTYPE</code> column values</caption>
<colgroup>
<col style="width: 20%;">
<col style="width: 20%;">
<col style="width: 60%;">
</colgroup>
<tbody>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">Database column value</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">Associated <code>RevisionType</code> Enum value</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">Description</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">0</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>ADD</code></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">A database table row was inserted.</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">1</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>MOD</code></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">A database table row was updated.</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">2</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>DEL</code></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">A database table row was deleted.</p></td>
</tr>
</tbody>
</table>
<div class="paragraph">
<p>The audit (history) of an entity can be accessed using the <code>AuditReader</code> interface, which can be obtained having an open <code>EntityManager</code> or <code>Session</code> via the <code>AuditReaderFactory</code>.</p>
</div>
<div id="envers-audited-revisions-example" class="exampleblock">
<div class="title">Example 5. Getting a list of revisions for the <code>Customer</code> entity</div>
<div class="content">
<div class="listingblock">
<div class="content">
<pre class="prettyprint highlight"><code class="language-JAVA" data-lang="JAVA">List&lt;Number&gt; revisions = doInJPA( this::entityManagerFactory, entityManager -&gt; {
     return AuditReaderFactory.get( entityManager ).getRevisions(
        Customer.class,
        1L
    );
} );</code></pre>
</div>
</div>
<div class="listingblock">
<div class="content">
<pre class="prettyprint highlight"><code class="language-SQL" data-lang="SQL">select
    c.REV as col_0_0_
from
    Customer_AUD c
cross join
    REVINFO r
where
    c.id = ?
    and c.REV = r.REV
order by
    c.REV asc

-- binding parameter [1] as [BIGINT] - [1]</code></pre>
</div>
</div>
</div>
</div>
<div class="paragraph">
<p>Using the previously fetched revisions, we can now inspect the state of the <code>Customer</code> entity at that particular revision:</p>
</div>
<div id="envers-audited-rev1-example" class="exampleblock">
<div class="title">Example 6. Getting the first revision for the <code>Customer</code> entity</div>
<div class="content">
<div class="listingblock">
<div class="content">
<pre class="prettyprint highlight"><code class="language-JAVA" data-lang="JAVA">Customer customer = (Customer) AuditReaderFactory
.get( entityManager )
.createQuery()
.forEntitiesAtRevision( Customer.class, revisions.get( 0 ) )
.getSingleResult();

assertEquals("Doe", customer.getLastName());</code></pre>
</div>
</div>
<div class="listingblock">
<div class="content">
<pre class="prettyprint highlight"><code class="language-SQL" data-lang="SQL">select
    c.id as id1_1_,
    c.REV as REV2_1_,
    c.REVTYPE as REVTYPE3_1_,
    c.created_on as created_4_1_,
    c.firstName as firstNam5_1_,
    c.lastName as lastName6_1_
from
    Customer_AUD c
where
    c.REV = (
        select
            max( c_max.REV )
        from
            Customer_AUD c_max
        where
            c_max.REV &lt;= ?
            and c.id = c_max.id
    )
    and c.REVTYPE &lt;&gt; ?

-- binding parameter [1] as [INTEGER] - [1]
-- binding parameter [2] as [INTEGER] - [2]</code></pre>
</div>
</div>
</div>
</div>
<div class="paragraph">
<p>When executing the aforementioned SQL query, there are two parameters:</p>
</div>
<div class="dlist">
<dl>
<dt class="hdlist1">revision_number</dt>
<dd>
<p>The first parameter marks the revision number we are interested in or the latest one that exist up to this particular revision.</p>
</dd>
<dt class="hdlist1">revision_type</dt>
<dd>
<p>The second parameter specifies that we are not interested in <code>DEL</code> <code>RevisionType</code> so that deleted entries are filtered out.</p>
</dd>
</dl>
</div>
<div class="paragraph">
<p>The same goes for the second revision associated to the <code>UPDATE</code> statement.</p>
</div>
<div id="envers-audited-rev2-example" class="exampleblock">
<div class="title">Example 7. Getting the second revision for the <code>Customer</code> entity</div>
<div class="content">
<div class="listingblock">
<div class="content">
<pre class="prettyprint highlight"><code class="language-JAVA" data-lang="JAVA">Customer customer = (Customer) AuditReaderFactory
.get( entityManager )
.createQuery()
.forEntitiesAtRevision( Customer.class, revisions.get( 1 ) )
.getSingleResult();

assertEquals("Doe Jr.", customer.getLastName());</code></pre>
</div>
</div>
</div>
</div>
<div class="paragraph">
<p>For the deleted entity revision, Envers throws a <code>NoResultException</code> since the entity was no longer valid at that revision.</p>
</div>
<div id="envers-audited-rev3-example" class="exampleblock">
<div class="title">Example 8. Getting the third revision for the <code>Customer</code> entity</div>
<div class="content">
<div class="listingblock">
<div class="content">
<pre class="prettyprint highlight"><code class="language-JAVA" data-lang="JAVA">try {
    Customer customer = (Customer) AuditReaderFactory
    .get( entityManager )
    .createQuery()
    .forEntitiesAtRevision( Customer.class, revisions.get( 2 ) )
    .getSingleResult();

    fail("The Customer was deleted at this revision: " + revisions.get( 2 ));
}
catch (NoResultException expected) {
}</code></pre>
</div>
</div>
</div>
</div>
<div class="paragraph">
<p>You can use the
<a href="https://docs.jboss.org/hibernate/orm/5.2/javadocs/org/hibernate/envers/query/AuditQueryCreator.html#forEntitiesAtRevision-java.lang.Class-java.lang.String-java.lang.Number-boolean-"><code>forEntitiesAtRevision(Class&lt;T&gt; cls, String entityName, Number revision, boolean includeDeletions)</code></a>
method to get the deleted entity revision so that, instead of a <code>NoResultException</code>,
all attributes, except for the entity identifier, are going to be <code>null</code>.</p>
</div>
<div id="envers-audited-rev4-example" class="exampleblock">
<div class="title">Example 9. Getting the third revision for the <code>Customer</code> entity without getting a <code>NoResultException</code></div>
<div class="content">
<div class="listingblock">
<div class="content">
<pre class="prettyprint highlight"><code class="language-JAVA" data-lang="JAVA">Customer customer = (Customer) AuditReaderFactory
.get( entityManager )
.createQuery()
.forEntitiesAtRevision(
    Customer.class,
    Customer.class.getName(),
    revisions.get( 2 ),
    true )
.getSingleResult();

assertEquals( Long.valueOf( 1L ), customer.getId() );
assertNull( customer.getFirstName() );
assertNull( customer.getLastName() );
assertNull( customer.getCreatedOn() );</code></pre>
</div>
</div>
</div>
</div>
<div class="paragraph">
<p>See the <a href="https://docs.jboss.org/hibernate/orm/5.2/javadocs/org/hibernate/envers/AuditReader.html">Javadocs</a> for details on other functionality offered.</p>
</div>
</div>
<div class="sect2">
<h3 id="envers-configuration">Configuration Properties</h3>
<div class="paragraph">
<p>It is possible to configure various aspects of Hibernate Envers behavior, such as table names, etc.</p>
</div>
<div class="dlist">
<dl>
<dt class="hdlist1"><code><strong>org.hibernate.envers.audit_table_prefix</strong></code></dt>
<dd>
<p>String that will be prepended to the name of an audited entity to create the name of the entity and that will hold audit information.</p>
</dd>
<dt class="hdlist1"><code><strong>org.hibernate.envers.audit_table_suffix</code></strong> (default: <code>_AUD</code>)</dt>
<dd>
<p>String that will be appended to the name of an audited entity to create the name of the entity and that will hold audit information.</p>
<div class="paragraph">
<p>If you audit an entity with a table name Person, in the default setting Envers will generate a <code>Person_AUD</code> table to store historical data.</p>
</div>
</dd>
<dt class="hdlist1"><code><strong>org.hibernate.envers.revision_field_name</strong></code> (default: <code>REV</code>)</dt>
<dd>
<p>Name of a field in the audit entity that will hold the revision number.</p>
</dd>
<dt class="hdlist1"><code><strong>org.hibernate.envers.revision_type_field_name</strong></code> (default: <code>REVTYPE</code> )</dt>
<dd>
<p>Name of a field in the audit entity that will hold the type of the revision (currently, this can be: <code>add</code>, <code>mod</code>, <code>del</code>).</p>
</dd>
<dt class="hdlist1"><code><strong>org.hibernate.envers.revision_on_collection_change</strong></code> (default: <code>true</code> )</dt>
<dd>
<p>Should a revision be generated when a not-owned relation field changes (this can be either a collection in a one-to-many relation, or the field using <code>mappedBy</code> attribute in a one-to-one relation).</p>
</dd>
<dt class="hdlist1"><code><strong>org.hibernate.envers.do_not_audit_optimistic_locking_field</strong></code> (default: <code>true</code> )</dt>
<dd>
<p>When true, properties to be used for optimistic locking, annotated with <code>@Version</code>, will not be automatically audited (their history won&#8217;t be stored; it normally doesn&#8217;t make sense to store it).</p>
</dd>
<dt class="hdlist1"><code><strong>org.hibernate.envers.store_data_at_delete</strong></code> (default: <code>false</code> )</dt>
<dd>
<p>Should the entity data be stored in the revision when the entity is deleted (instead of only storing the id and all other properties as null).</p>
<div class="paragraph">
<p>This is not normally needed, as the data is present in the last-but-one revision.
Sometimes, however, it is easier and more efficient to access it in the last revision (then the data that the entity contained before deletion is stored twice).</p>
</div>
</dd>
<dt class="hdlist1"><code><strong>org.hibernate.envers.default_schema</strong></code> (default: <code>null</code> - same schema as table being audited)</dt>
<dd>
<p>The default schema name that should be used for audit tables.</p>
<div class="paragraph">
<p>Can be overridden using the <code>@AuditTable( schema="&#8230;&#8203;" )</code> annotation.</p>
</div>
<div class="paragraph">
<p>If not present, the schema will be the same as the schema of the table being audited.</p>
</div>
</dd>
<dt class="hdlist1"><code><strong>org.hibernate.envers.default_catalog</strong></code> (default: <code>null</code> - same catalog as table being audited)</dt>
<dd>
<p>The default catalog name that should be used for audit tables.</p>
<div class="paragraph">
<p>Can be overridden using the <code>@AuditTable( catalog="&#8230;&#8203;" )</code> annotation.</p>
</div>
<div class="paragraph">
<p>If not present, the catalog will be the same as the catalog of the normal tables.</p>
</div>
</dd>
<dt class="hdlist1"><code><strong>org.hibernate.envers.audit_strategy</strong></code>(default: <code>org.hibernate.envers.strategy.DefaultAuditStrategy</code> )</dt>
<dd>
<p>The audit strategy that should be used when persisting audit data.
The default stores only the revision, at which an entity was modified.</p>
<div class="paragraph">
<p>An alternative, the <code>org.hibernate.envers.strategy.ValidityAuditStrategy</code> stores both the start revision and the end revision.
Together these define when an audit row was valid, hence the name ValidityAuditStrategy.</p>
</div>
</dd>
<dt class="hdlist1"><code><strong>org.hibernate.envers.audit_strategy_validity_end_rev_field_name</strong></code> (default: <code>REVEND</code>)</dt>
<dd>
<p>The column name that will hold the end revision number in audit entities.
This property is only valid if the validity audit strategy is used.</p>
</dd>
<dt class="hdlist1"><code><strong>org.hibernate.envers.audit_strategy_validity_store_revend_timestamp</strong></code>(default: <code>false</code> )</dt>
<dd>
<p>Should the timestamp of the end revision be stored, until which the data was valid, in addition to the end revision itself.
This is useful to be able to purge old Audit records out of a relational database by using table partitioning.</p>
<div class="paragraph">
<p>Partitioning requires a column that exists within the table.
This property is only evaluated if the <code>ValidityAuditStrategy</code> is used.</p>
</div>
</dd>
<dt class="hdlist1"><code><strong>org.hibernate.envers.audit_strategy_validity_revend_timestamp_field_name</strong></code>(default: <code>REVEND_TSTMP</code> )</dt>
<dd>
<p>Column name of the timestamp of the end revision until which the data was valid.
Only used if the <code>ValidityAuditStrategy</code> is used, and <code>org.hibernate.envers.audit_strategy_validity_store_revend_timestamp</code> evaluates to true</p>
</dd>
<dt class="hdlist1"><code><strong>org.hibernate.envers.use_revision_entity_with_native_id</strong></code> (default: <code>true</code> )</dt>
<dd>
<p>Boolean flag that determines the strategy of revision number generation.
Default implementation of revision entity uses native identifier generator.</p>
<div class="paragraph">
<p>If current database engine does not support identity columns, users are advised to set this property to false.</p>
</div>
<div class="paragraph">
<p>In this case revision numbers are created by preconfigured <code>org.hibernate.id.enhanced.SequenceStyleGenerator</code>.
See: <code>org.hibernate.envers.DefaultRevisionEntity</code> and <code>org.hibernate.envers.enhanced.SequenceIdRevisionEntity</code>.</p>
</div>
</dd>
<dt class="hdlist1"><code><strong>org.hibernate.envers.track_entities_changed_in_revision</strong></code> (default: <code>false</code> )</dt>
<dd>
<p>Should entity types, that have been modified during each revision, be tracked.
The default implementation creates <code>REVCHANGES</code> table that stores entity names of modified persistent objects.
Single record encapsulates the revision identifier (foreign key to <code>REVINFO</code> table) and a string value.
For more information, refer to <a href="#envers-tracking-modified-entities-revchanges">Tracking entity names modified during revisions</a> and <a href="#envers-tracking-modified-entities-queries">Querying for entity types modified in a given revision</a>.</p>
</dd>
<dt class="hdlist1"><code><strong>org.hibernate.envers.global_with_modified_flag</strong></code> (default: <code>false</code>, can be individually overridden with <code>@Audited( withModifiedFlag=true )</code> )</dt>
<dd>
<p>Should property modification flags be stored for all audited entities and all properties.</p>
<div class="paragraph">
<p>When set to true, for all properties an additional boolean column in the audit tables will be created, filled with information if the given property changed in the given revision.</p>
</div>
<div class="paragraph">
<p>When set to false, such column can be added to selected entities or properties using the <code>@Audited</code> annotation.</p>
</div>
<div class="paragraph">
<p>For more information, refer to <a href="#envers-tracking-properties-changes">Tracking entity changes at property level</a> and <a href="#envers-tracking-properties-changes-queries">Querying for revisions of entity that modified a given property</a>.</p>
</div>
</dd>
<dt class="hdlist1"><code><strong>org.hibernate.envers.modified_flag_suffix</strong></code> (default: <code>_MOD</code> )</dt>
<dd>
<p>The suffix for columns storing "Modified Flags".</p>
<div class="paragraph">
<p>For example: a property called "age", will by default get modified flag with column name "age_MOD".</p>
</div>
</dd>
<dt class="hdlist1"><code><strong>org.hibernate.envers.embeddable_set_ordinal_field_name</strong></code> (default: <code>SETORDINAL</code> )</dt>
<dd>
<p>Name of column used for storing ordinal of the change in sets of embeddable elements.</p>
</dd>
<dt class="hdlist1"><code><strong>org.hibernate.envers.cascade_delete_revision</strong></code> (default: <code>false</code> )</dt>
<dd>
<p>While deleting revision entry, remove data of associated audited entities. Requires database support for cascade row removal.</p>
</dd>
<dt class="hdlist1"><code><strong>org.hibernate.envers.allow_identifier_reuse</strong></code> (default: <code>false</code> )</dt>
<dd>
<p>Guarantees proper validity audit strategy behavior when application reuses identifiers of deleted entities. Exactly one row with <code>null</code> end date exists for each identifier.</p>
</dd>
<dt class="hdlist1"><code><strong>org.hibernate.envers.original_id_prop_name</strong></code> (default: <code>originalId</code> )</dt>
<dd>
<p>Specifies the composite-id key property name used by the audit table mappings.</p>
</dd>
</dl>
</div>
<div class="admonitionblock important">
<table>
<tr>
<td class="icon">
<i class="fa icon-important" title="Important"></i>
</td>
<td class="content">
<div class="paragraph">
<p>The following configuration options have been added recently and should
be regarded as experimental:</p>
</div>
<div class="olist arabic">
<ol class="arabic">
<li>
<p><code>org.hibernate.envers.track_entities_changed_in_revision</code></p>
</li>
<li>
<p><code>org.hibernate.envers.using_modified_flag</code></p>
</li>
<li>
<p><code>org.hibernate.envers.modified_flag_suffix</code></p>
</li>
<li>
<p><code>org.hibernate.envers.original_id_prop_name</code></p>
</li>
</ol>
</div>
</td>
</tr>
</table>
</div>
</div>
<div class="sect2">
<h3 id="envers-additional-mappings">Additional mapping annotations</h3>
<div class="paragraph">
<p>The name of the audit table can be set on a per-entity basis, using the <code>@AuditTable</code> annotation.
It may be tedious to add this annotation to every audited entity, so if possible, it&#8217;s better to use a prefix/suffix.</p>
</div>
<div class="paragraph">
<p>If you have a mapping with secondary tables, audit tables for them will be generated in the same way (by adding the prefix and suffix).
If you wish to overwrite this behavior, you can use the <code>@SecondaryAuditTable</code> and <code>@SecondaryAuditTables</code> annotations.</p>
</div>
<div class="paragraph">
<p>If you&#8217;d like to override auditing behavior of some fields/properties inherited from <code>@MappedSuperclass</code> or in an embedded component,
you can apply the <code>@AuditOverride</code> annotation on the subtype or usage site of the component.</p>
</div>
<div class="paragraph">
<p>If you want to audit a relation mapped with <code>@OneToMany</code> and <code>@JoinColumn</code>,
please see <a href="#envers-mappingexceptions">Mapping exceptions</a> for a description of the additional <code>@AuditJoinTable</code> annotation that you&#8217;ll probably want to use.</p>
</div>
<div class="paragraph">
<p>If you want to audit a relation, where the target entity is not audited (that is the case for example with dictionary-like entities, which don&#8217;t change and don&#8217;t have to be audited),
just annotate it with <code>@Audited( targetAuditMode = RelationTargetAuditMode.NOT_AUDITED )</code>.
Then, while reading historic versions of your entity, the relation will always point to the "current" related entity.
By default Envers throws <code>javax.persistence.EntityNotFoundException</code> when "current" entity does not exist in the database.
Apply <code>@NotFound( action = NotFoundAction.IGNORE )</code> annotation to silence the exception and assign null value instead.
The hereby solution causes implicit eager loading of to-one relations.</p>
</div>
<div class="paragraph">
<p>If you&#8217;d like to audit properties of a superclass of an entity, which are not explicitly audited (they don&#8217;t have the <code>@Audited</code> annotation on any properties or on the class),
you can set the <code>@AuditOverride( forClass = SomeEntity.class, isAudited = true/false )</code> annotation.</p>
</div>
<div class="admonitionblock note">
<table>
<tr>
<td class="icon">
<i class="fa icon-note" title="Note"></i>
</td>
<td class="content">
<div class="paragraph">
<p>The <code>@Audited</code> annotation also features an <code>auditParents</code> attribute but it&#8217;s now deprecated in favor of <code>@AuditOverride</code>,</p>
</div>
</td>
</tr>
</table>
</div>
</div>
<div class="sect2">
<h3 id="envers-audit-strategy">Choosing an audit strategy</h3>
<div class="paragraph">
<p>After the basic configuration, it is important to choose the audit strategy that will be used to persist and retrieve audit information.
There is a trade-off between the performance of persisting and the performance of querying the audit information.
Currently, there are two audit strategies.</p>
</div>
<div class="olist arabic">
<ol class="arabic">
<li>
<p>The default audit strategy persists the audit data together with a start revision.
For each row inserted, updated or deleted in an audited table, one or more rows are inserted in the audit tables, together with the start revision of its validity.
Rows in the audit tables are never updated after insertion.
Queries of audit information use subqueries to select the applicable rows in the audit tables.</p>
<div class="admonitionblock important">
<table>
<tr>
<td class="icon">
<i class="fa icon-important" title="Important"></i>
</td>
<td class="content">
These subqueries are notoriously slow and difficult to index.
</td>
</tr>
</table>
</div>
</li>
<li>
<p>The alternative is a validity audit strategy.
This strategy stores the start-revision and the end-revision of audit information.
For each row inserted, updated or deleted in an audited table, one or more rows are inserted in the audit tables, together with the start revision of its validity.
But at the same time the end-revision field of the previous audit rows (if available) are set to this revision.
Queries on the audit information can then use 'between start and end revision' instead of subqueries as used by the default audit strategy.</p>
<div class="paragraph">
<p>The consequence of this strategy is that persisting audit information will be a bit slower because of the extra updates involved,
but retrieving audit information will be a lot faster.</p>
</div>
<div class="admonitionblock important">
<table>
<tr>
<td class="icon">
<i class="fa icon-important" title="Important"></i>
</td>
<td class="content">
This can be improved even further by adding extra indexes.
</td>
</tr>
</table>
</div>
</li>
</ol>
</div>
<div class="sect3">
<h4 id="envers-audit-ValidityAuditStrategy">Configuring the <code>ValidityAuditStrategy</code></h4>
<div class="paragraph">
<p>To better visualize how the <code>ValidityAuditStrategy</code>, consider the following exercise where
we replay the previous audit logging example for the <code>Customer</code> entity.</p>
</div>
<div class="paragraph">
<p>First, you need to configure the <code>ValidityAuditStrategy</code>:</p>
</div>
<div id="envers-audited-validity-configuration-example" class="exampleblock">
<div class="title">Example 10. Configuring the <code>ValidityAuditStrategy</code></div>
<div class="content">
<div class="listingblock">
<div class="content">
<pre class="prettyprint highlight"><code class="language-JAVA" data-lang="JAVA">options.put(
    EnversSettings.AUDIT_STRATEGY,
    ValidityAuditStrategy.class.getName()
);</code></pre>
</div>
</div>
</div>
</div>
<div class="paragraph">
<p>If, you&#8217;re using the <code>persistence.xml</code> configuration file,
then the mapping will looks as follows:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="prettyprint highlight"><code class="language-XML" data-lang="XML">&lt;property
    name="org.hibernate.envers.audit_strategy"
    value="org.hibernate.envers.strategy.ValidityAuditStrategy"
/&gt;</code></pre>
</div>
</div>
<div class="paragraph">
<p>Once you configured the <code>ValidityAuditStrategy</code>, the following schema is going to be automatically generated:</p>
</div>
<div id="envers-audited-validity-mapping-example" class="exampleblock">
<div class="title">Example 11. Envers schema for the <code>ValidityAuditStrategy</code></div>
<div class="content">
<div class="listingblock">
<div class="content">
<pre class="prettyprint highlight"><code class="language-SQL" data-lang="SQL">create table Customer (
    id bigint not null,
    created_on timestamp,
    firstName varchar(255),
    lastName varchar(255),
    primary key (id)
)

create table Customer_AUD (
   id bigint not null,
    REV integer not null,
    REVTYPE tinyint,
    REVEND integer,
    created_on timestamp,
    firstName varchar(255),
    lastName varchar(255),
    primary key (id, REV)
)

create table REVINFO (
    REV integer generated by default as identity,
    REVTSTMP bigint,
    primary key (REV)
)

alter table Customer_AUD
    add constraint FK5ecvi1a0ykunrriib7j28vpdj
    foreign key (REV)
    references REVINFO

alter table Customer_AUD
    add constraint FKqd4fy7ww1yy95wi4wtaonre3f
    foreign key (REVEND)
    references REVINFO</code></pre>
</div>
</div>
</div>
</div>
<div class="paragraph">
<p>As you can see, the <code>REVEND</code> column is added as well as its Foreign key to the <code>REVINFO</code> table.</p>
</div>
<div class="paragraph">
<p>When rerunning thee previous <code>Customer</code> audit log queries against the <code>ValidityAuditStrategy</code>,
we get the following results:</p>
</div>
<div id="envers-audited-validity-rev1-example" class="exampleblock">
<div class="title">Example 12. Getting the first revision for the <code>Customer</code> entity</div>
<div class="content">
<div class="listingblock">
<div class="content">
<pre class="prettyprint highlight"><code class="language-SQL" data-lang="SQL">select
    c.id as id1_1_,
    c.REV as REV2_1_,
    c.REVTYPE as REVTYPE3_1_,
    c.REVEND as REVEND4_1_,
    c.created_on as created_5_1_,
    c.firstName as firstNam6_1_,
    c.lastName as lastName7_1_
from
    Customer_AUD c
where
    c.REV &lt;= ?
    and c.REVTYPE &lt;&gt; ?
    and (
        c.REVEND &gt; ?
        or c.REVEND is null
    )

-- binding parameter [1] as [INTEGER] - [1]
-- binding parameter [2] as [INTEGER] - [2]
-- binding parameter [3] as [INTEGER] - [1]</code></pre>
</div>
</div>
</div>
</div>
<div class="admonitionblock note">
<table>
<tr>
<td class="icon">
<i class="fa icon-note" title="Note"></i>
</td>
<td class="content">
<div class="paragraph">
<p>Compared to the default strategy, the <code>ValidityAuditStrategy</code> generates simpler queries that can render better execution plans.</p>
</div>
</td>
</tr>
</table>
</div>
</div>
</div>
<div class="sect2">
<h3 id="envers-revisionlog">Revision Log</h3>
<div class="paragraph">
<p>When Envers starts a new revision, it creates a new revision entity which stores information about the revision.</p>
</div>
<div class="paragraph">
<p>By default, that includes just:</p>
</div>
<div class="dlist">
<dl>
<dt class="hdlist1">revision number</dt>
<dd>
<p>An integral value (<code>int/Integer</code> or <code>long/Long</code>). Essentially the primary key of the revision</p>
</dd>
<dt class="hdlist1">revision timestamp</dt>
<dd>
<p>Either a <code>long/Long</code> or <code>java.util.Date</code> value representing the instant at which the revision was made.
When using a <code>java.util.Date</code>, instead of a <code>long/Long</code> for the revision timestamp, take care not to store it to a column data type which will loose precision.</p>
</dd>
</dl>
</div>
<div class="paragraph">
<p>Envers handles this information as an entity.
By default it uses its own internal class to act as the entity, mapped to the <code>REVINFO</code> table.
You can, however, supply your own approach to collecting this information which might be useful to capture additional details such as who made a change
or the ip address from which the request came.
There are two things you need to make this work:</p>
</div>
<div class="olist arabic">
<ol class="arabic">
<li>
<p>First, you will need to tell Envers about the entity you wish to use.
Your entity must use the <code>@org.hibernate.envers.RevisionEntity</code> annotation.
It must define the two attributes described above annotated with <code>@org.hibernate.envers.RevisionNumber</code> and <code>@org.hibernate.envers.RevisionTimestamp</code>, respectively.
You can extend from <code>org.hibernate.envers.DefaultRevisionEntity</code>, if you wish, to inherit all these required behaviors.</p>
<div class="paragraph">
<p>Simply add the custom revision entity as you do your normal entities and Envers will <strong>find it</strong>.</p>
</div>
<div class="admonitionblock note">
<table>
<tr>
<td class="icon">
<i class="fa icon-note" title="Note"></i>
</td>
<td class="content">
It is an error for there to be multiple entities marked as <code>@org.hibernate.envers.RevisionEntity</code>
</td>
</tr>
</table>
</div>
</li>
<li>
<p>Second, you need to tell Envers how to create instances of your revision entity which is handled by the
<a href="https://docs.jboss.org/hibernate/orm/5.2/javadocs/org/hibernate/envers/RevisionListener.html#newRevision-java.lang.Object-"><code>newRevision( Object revisionEntity )</code></a>
method of the <code>org.hibernate.envers.RevisionListener</code> interface.</p>
<div class="paragraph">
<p>You tell Envers your custom <code>org.hibernate.envers.RevisionListener</code> implementation to use by specifying it on the <code>@org.hibernate.envers.RevisionEntity</code> annotation, using the value attribute.
If your <code>RevisionListener</code> class is inaccessible from <code>@RevisionEntity</code> (e.g. it exists in a different module),
set <code>org.hibernate.envers.revision_listener</code> property to its fully qualified class name.
Class name defined by the configuration parameter overrides revision entity&#8217;s value attribute.</p>
</div>
</li>
</ol>
</div>
<div class="paragraph">
<p>Considering we have a <code>CurrentUser</code> utility which stores the current logged user:</p>
</div>
<div id="envers-revisionlog-CurrentUser-example" class="exampleblock">
<div class="title">Example 13. <code>CurrentUser</code> utility</div>
<div class="content">
<div class="listingblock">
<div class="content">
<pre class="prettyprint highlight"><code class="language-JAVA" data-lang="JAVA">public static class CurrentUser {

    public static final CurrentUser INSTANCE = new CurrentUser();

    private static final ThreadLocal&lt;String&gt; storage = new ThreadLocal&lt;&gt;();

    public void logIn(String user) {
        storage.set( user );
    }

    public void logOut() {
        storage.remove();
    }

    public String get() {
        return storage.get();
    }
}</code></pre>
</div>
</div>
</div>
</div>
<div class="paragraph">
<p>Now, we need to provide a custom <code>@RevisionEntity</code> to store the currently logged user</p>
</div>
<div id="envers-revisionlog-RevisionEntity-example" class="exampleblock">
<div class="title">Example 14. Custom <code>@RevisionEntity</code> example</div>
<div class="content">
<div class="listingblock">
<div class="content">
<pre class="prettyprint highlight"><code class="language-JAVA" data-lang="JAVA">@Entity(name = "CustomRevisionEntity")
@Table(name = "CUSTOM_REV_INFO")
@RevisionEntity( CustomRevisionEntityListener.class )
public static class CustomRevisionEntity extends DefaultRevisionEntity {

    private String username;

    public String getUsername() {
        return username;
    }

    public void setUsername( String username ) {
        this.username = username;
    }
}</code></pre>
</div>
</div>
</div>
</div>
<div class="paragraph">
<p>With the custom <code>RevisionEntity</code> implementation in place,
we only need to provide the <code>RevisionEntity</code> implementation which acts as a factory
of <code>RevisionEntity</code> instances.</p>
</div>
<div id="envers-revisionlog-RevisionListener-example" class="exampleblock">
<div class="title">Example 15. Custom <code>@RevisionListener</code> example</div>
<div class="content">
<div class="listingblock">
<div class="content">
<pre class="prettyprint highlight"><code class="language-JAVA" data-lang="JAVA">public static class CustomRevisionEntityListener implements RevisionListener {

    public void newRevision( Object revisionEntity ) {
        CustomRevisionEntity customRevisionEntity =
            ( CustomRevisionEntity ) revisionEntity;

        customRevisionEntity.setUsername(
            CurrentUser.INSTANCE.get()
        );
    }
}</code></pre>
</div>
</div>
</div>
</div>
<div class="paragraph">
<p>When generating the database schema, Envers creates the following <code>RevisionEntity</code> table:</p>
</div>
<div id="envers-revisionlog-custom-revision-entity-table-example" class="exampleblock">
<div class="title">Example 16. Auto-generated <code>RevisionEntity</code> Envers table</div>
<div class="content">
<div class="listingblock">
<div class="content">
<pre class="prettyprint highlight"><code class="language-SQL" data-lang="SQL">create table CUSTOM_REV_INFO (
    id integer not null,
    timestamp bigint not null,
    username varchar(255),
    primary key (id)
)</code></pre>
</div>
</div>
</div>
</div>
<div class="paragraph">
<p>You can see the <code>username</code> column in place.</p>
</div>
<div class="paragraph">
<p>Now, when inserting a <code>Customer</code> entity, Envers generates the following statements:</p>
</div>
<div id="envers-revisionlog-RevisionEntity-persist-example" class="exampleblock">
<div class="title">Example 17. Auditing using the custom <code>@RevisionEntity</code> instance</div>
<div class="content">
<div class="listingblock">
<div class="content">
<pre class="prettyprint highlight"><code class="language-JAVA" data-lang="JAVA">CurrentUser.INSTANCE.logIn( "Vlad Mihalcea" );

doInJPA( this::entityManagerFactory, entityManager -&gt; {
    Customer customer = new Customer();
    customer.setId( 1L );
    customer.setFirstName( "John" );
    customer.setLastName( "Doe" );

    entityManager.persist( customer );
} );

CurrentUser.INSTANCE.logOut();</code></pre>
</div>
</div>
<div class="listingblock">
<div class="content">
<pre class="prettyprint highlight"><code class="language-SQL" data-lang="SQL">insert
into
    Customer
    (created_on, firstName, lastName, id)
values
    (?, ?, ?, ?)

-- binding parameter [1] as [TIMESTAMP] - [Thu Jul 27 15:45:00 EEST 2017]
-- binding parameter [2] as [VARCHAR]   - [John]
-- binding parameter [3] as [VARCHAR]   - [Doe]
-- binding parameter [4] as [BIGINT]    - [1]

insert
into
    CUSTOM_REV_INFO
    (timestamp, username, id)
values
    (?, ?, ?)

-- binding parameter [1] as [BIGINT]  - [1501159500888]
-- binding parameter [2] as [VARCHAR] - [Vlad Mihalcea]
-- binding parameter [3] as [INTEGER] - [1]

insert
into
    Customer_AUD
    (REVTYPE, created_on, firstName, lastName, id, REV)
values
    (?, ?, ?, ?, ?, ?)

-- binding parameter [1] as [INTEGER]   - [0]
-- binding parameter [2] as [TIMESTAMP] - [Thu Jul 27 15:45:00 EEST 2017]
-- binding parameter [3] as [VARCHAR]   - [John]
-- binding parameter [4] as [VARCHAR]   - [Doe]
-- binding parameter [5] as [BIGINT]    - [1]
-- binding parameter [6] as [INTEGER]   - [1]</code></pre>
</div>
</div>
</div>
</div>
<div class="paragraph">
<p>As demonstrated by the example above, the username is properly set and propagated to the <code>CUSTOM_REV_INFO</code> table.</p>
</div>
<div class="admonitionblock warning">
<table>
<tr>
<td class="icon">
<i class="fa icon-warning" title="Warning"></i>
</td>
<td class="content">
<div class="paragraph">
<p><strong>This strategy is deprecated since version 5.2 as an alternative is going to be provided in Hibernate Envers 6.0.</strong></p>
</div>
<div class="paragraph">
<p>An alternative method to using the <code>org.hibernate.envers.RevisionListener</code> is to instead call the
<span class="line-through"><a href="https://docs.jboss.org/hibernate/orm/5.2/javadocs/org/hibernate/envers/AuditReader.html#getCurrentRevision-java.lang.Class-boolean-"><code>getCurrentRevision( Class&lt;T&gt; revisionEntityClass, boolean persist )</code></a></span>
method of the <code>org.hibernate.envers.AuditReader</code> interface to obtain the current revision,
and fill it with desired information.</p>
</div>
<div class="paragraph">
<p>The method accepts a <code>persist</code> parameter indicating whether the revision entity should be persisted prior to returning from this method:</p>
</div>
<div class="dlist">
<dl>
<dt class="hdlist1"><code>true</code></dt>
<dd>
<p>ensures that the returned entity has access to its identifier value (revision number), but the revision entity will be persisted regardless of whether there are any audited entities changed.</p>
</dd>
<dt class="hdlist1"><code>false</code></dt>
<dd>
<p>means that the revision number will be <code>null</code>, but the revision entity will be persisted only if some audited entities have changed.</p>
</dd>
</dl>
</div>
</td>
</tr>
</table>
</div>
</div>
<div class="sect2">
<h3 id="envers-tracking-modified-entities-revchanges">Tracking entity names modified during revisions</h3>
<div class="paragraph">
<p>By default, entity types that have been changed in each revision are not being tracked.
This implies the necessity to query all tables storing audited data in order to retrieve changes made during specified revision.
Envers provides a simple mechanism that creates <code>REVCHANGES</code> table which stores entity names of modified persistent objects.
Single record encapsulates the revision identifier (foreign key to <code>REVINFO</code> table) and a string value.</p>
</div>
<div class="paragraph">
<p>Tracking of modified entity names can be enabled in three different ways:</p>
</div>
<div class="olist arabic">
<ol class="arabic">
<li>
<p>Set <code>org.hibernate.envers.track_entities_changed_in_revision</code> parameter to <code>true</code>.
In this case <code>org.hibernate.envers.DefaultTrackingModifiedEntitiesRevisionEntity</code> will be implicitly used as the revision log entity.</p>
</li>
<li>
<p>Create a custom revision entity that extends <code>org.hibernate.envers.DefaultTrackingModifiedEntitiesRevisionEntity</code> class.</p>
<div class="listingblock">
<div class="content">
<pre class="prettyprint highlight"><code class="language-JAVA" data-lang="JAVA">@Entity(name = "CustomTrackingRevisionEntity")
@Table(name = "TRACKING_REV_INFO")
@RevisionEntity
public static class CustomTrackingRevisionEntity
    extends DefaultTrackingModifiedEntitiesRevisionEntity {

}</code></pre>
</div>
</div>
</li>
<li>
<p>Mark an appropriate field of a custom revision entity with <code>@org.hibernate.envers.ModifiedEntityNames</code> annotation.
The property is required to be of <code>Set&lt;String&gt;</code> type.</p>
<div class="listingblock">
<div class="content">
<pre class="prettyprint highlight"><code class="language-JAVA" data-lang="JAVA">@Entity(name = "CustomTrackingRevisionEntity")
@Table(name = "TRACKING_REV_INFO")
@RevisionEntity
public static class CustomTrackingRevisionEntity extends DefaultRevisionEntity {

    @ElementCollection
    @JoinTable(
        name = "REVCHANGES",
        joinColumns = @JoinColumn( name = "REV" )
    )
    @Column( name = "ENTITYNAME" )
    @ModifiedEntityNames
    private Set&lt;String&gt; modifiedEntityNames = new HashSet&lt;&gt;();

    public Set&lt;String&gt; getModifiedEntityNames() {
        return modifiedEntityNames;
    }
}</code></pre>
</div>
</div>
</li>
</ol>
</div>
<div class="paragraph">
<p>Considering we have a <code>Customer</code> entity illustrated by the following example:</p>
</div>
<div id="envers-tracking-modified-entities-revchanges-before-rename-example" class="exampleblock">
<div class="title">Example 18. <code>Customer</code> entity before renaming</div>
<div class="content">
<div class="listingblock">
<div class="content">
<pre class="prettyprint highlight"><code class="language-JAVA" data-lang="JAVA">@Audited
@Entity(name = "Customer")
public static class Customer {

    @Id
    private Long id;

    private String firstName;

    private String lastName;

    @Temporal( TemporalType.TIMESTAMP )
    @Column(name = "created_on")
    @CreationTimestamp
    private Date createdOn;

    //Getters and setters are omitted for brevity
}</code></pre>
</div>
</div>
</div>
</div>
<div class="paragraph">
<p>If the <code>Customer</code> entity class name is changed to <code>ApplicationCustomer</code>,
Envers is going to insert a new record in the <code>REVCHANGES</code> table with the previous entity class name:</p>
</div>
<div id="envers-tracking-modified-entities-revchanges-after-rename-example" class="exampleblock">
<div class="title">Example 19. <code>Customer</code> entity after renaming</div>
<div class="content">
<div class="listingblock">
<div class="content">
<pre class="prettyprint highlight"><code class="language-JAVA" data-lang="JAVA">@Audited
@Entity(name = "Customer")
public static class ApplicationCustomer {

    @Id
    private Long id;

    private String firstName;

    private String lastName;

    @Temporal( TemporalType.TIMESTAMP )
    @Column(name = "created_on")
    @CreationTimestamp
    private Date createdOn;

    //Getters and setters are omitted for brevity
}</code></pre>
</div>
</div>
<div class="listingblock">
<div class="content">
<pre class="prettyprint highlight"><code class="language-SQL" data-lang="SQL">insert
into
    REVCHANGES
    (REV, ENTITYNAME)
values
    (?, ?)

-- binding parameter [1] as [INTEGER] - [1]
-- binding parameter [2] as [VARCHAR] - [org.hibernate.userguide.envers.EntityTypeChangeAuditTest$Customer]</code></pre>
</div>
</div>
</div>
</div>
<div class="paragraph">
<p>Users, that have chosen one of the approaches listed above,
can retrieve all entities modified in a specified revision by utilizing API described in <a href="#envers-tracking-modified-entities-queries">Querying for entity types modified in a given revision</a>.</p>
</div>
<div class="paragraph">
<p>Users are also allowed to implement custom mechanism of tracking modified entity types.
In this case, they shall pass their own implementation of <code>org.hibernate.envers.EntityTrackingRevisionListener</code>
interface as the value of <code>@org.hibernate.envers.RevisionEntity</code> annotation.</p>
</div>
<div class="paragraph">
<p><code>EntityTrackingRevisionListener</code> interface exposes one method that notifies whenever audited entity instance has been
added, modified or removed within current revision boundaries.</p>
</div>
<div id="envers-tracking-modified-entities-revchanges-EntityTrackingRevisionListener-example" class="exampleblock">
<div class="title">Example 20. The <code>EntityTrackingRevisionListener</code> implementation</div>
<div class="content">
<div class="listingblock">
<div class="content">
<pre class="prettyprint highlight"><code class="language-JAVA" data-lang="JAVA">public static class CustomTrackingRevisionListener implements EntityTrackingRevisionListener {

    @Override
    public void entityChanged(Class entityClass,
                              String entityName,
                              Serializable entityId,
                              RevisionType revisionType,
                              Object revisionEntity ) {
        String type = entityClass.getName();
        ( (CustomTrackingRevisionEntity) revisionEntity ).addModifiedEntityType( type );
    }

    @Override
    public void newRevision( Object revisionEntity ) {
    }
}</code></pre>
</div>
</div>
</div>
</div>
<div class="paragraph">
<p>The <code>CustomTrackingRevisionListener</code> adds the fully-qualified class name to the <code>modifiedEntityTypes</code> attribute of the <code>CustomTrackingRevisionEntity</code>.</p>
</div>
<div id="envers-tracking-modified-entities-revchanges-RevisionEntity-example" class="exampleblock">
<div class="title">Example 21. The <code>RevisionEntity</code> using the custom <code>EntityTrackingRevisionListener</code></div>
<div class="content">
<div class="listingblock">
<div class="content">
<pre class="prettyprint highlight"><code class="language-JAVA" data-lang="JAVA">@Entity(name = "CustomTrackingRevisionEntity")
@Table(name = "TRACKING_REV_INFO")
@RevisionEntity( CustomTrackingRevisionListener.class )
public static class CustomTrackingRevisionEntity {

    @Id
    @GeneratedValue
    @RevisionNumber
    private int customId;

    @RevisionTimestamp
    private long customTimestamp;

    @OneToMany(
        mappedBy="revision",
        cascade={
            CascadeType.PERSIST,
            CascadeType.REMOVE
        }
    )
    private Set&lt;EntityType&gt; modifiedEntityTypes = new HashSet&lt;&gt;();

    public Set&lt;EntityType&gt; getModifiedEntityTypes() {
        return modifiedEntityTypes;
    }

    public void addModifiedEntityType(String entityClassName ) {
        modifiedEntityTypes.add( new EntityType( this, entityClassName ) );
    }
}</code></pre>
</div>
</div>
</div>
</div>
<div class="paragraph">
<p>The <code>CustomTrackingRevisionEntity</code> contains a <code>@OneToMany</code> list of <code>ModifiedTypeRevisionEntity</code></p>
</div>
<div id="envers-tracking-modified-entities-revchanges-EntityType-example" class="exampleblock">
<div class="title">Example 22. The <code>EntityType</code> encapsulatets the entity type name before a class name modification</div>
<div class="content">
<div class="listingblock">
<div class="content">
<pre class="prettyprint highlight"><code class="language-JAVA" data-lang="JAVA">@Entity(name = "EntityType")
public static class EntityType {

    @Id
    @GeneratedValue
    private Integer id;

    @ManyToOne
    private CustomTrackingRevisionEntity revision;

    private String entityClassName;

    private EntityType() {
    }

    public EntityType(CustomTrackingRevisionEntity revision, String entityClassName) {
        this.revision = revision;
        this.entityClassName = entityClassName;
    }

    //Getters and setters are omitted for brevity
}</code></pre>
</div>
</div>
</div>
</div>
<div class="paragraph">
<p>Now, when fetching the <code>CustomTrackingRevisionEntity</code>, you cna get access to the previous entity class name.</p>
</div>
<div id="envers-tracking-modified-entities-revchanges-query-example" class="exampleblock">
<div class="title">Example 23. Getting the <code>EntityType</code> through the <code>CustomTrackingRevisionEntity</code></div>
<div class="content">
<div class="listingblock">
<div class="content">
<pre class="prettyprint highlight"><code class="language-JAVA" data-lang="JAVA">AuditReader auditReader = AuditReaderFactory.get( entityManager );

List&lt;Number&gt; revisions = auditReader.getRevisions(
    ApplicationCustomer.class,
    1L
);

CustomTrackingRevisionEntity revEntity = auditReader.findRevision(
    CustomTrackingRevisionEntity.class,
    revisions.get( 0 )
);

Set&lt;EntityType&gt; modifiedEntityTypes = revEntity.getModifiedEntityTypes();
assertEquals( 1, modifiedEntityTypes.size() );

EntityType entityType = modifiedEntityTypes.iterator().next();
assertEquals(
    Customer.class.getName(),
    entityType.getEntityClassName()
);</code></pre>
</div>
</div>
</div>
</div>
</div>
<div class="sect2">
<h3 id="envers-tracking-properties-changes">Tracking entity changes at property level</h3>
<div class="paragraph">
<p>By default, the only information stored by Envers are revisions of modified entities.
This approach lets user create audit queries based on historical values of entity properties.
Sometimes it is useful to store additional metadata for each revision, when you are interested also in the type of changes, not only about the resulting values.</p>
</div>
<div class="paragraph">
<p>The feature described in <a href="#envers-tracking-modified-entities-revchanges">Tracking entity names modified during revisions</a> makes it possible to tell which entities were modified in a given revision.</p>
</div>
<div class="paragraph">
<p>The feature described here takes it one step further.
<em>Modification Flags</em> enable Envers to track which properties of audited entities were modified in a given revision.</p>
</div>
<div class="paragraph">
<p>Tracking entity changes at property level can be enabled by:</p>
</div>
<div class="olist arabic">
<ol class="arabic">
<li>
<p>setting <code>org.hibernate.envers.global_with_modified_flag</code> configuration property to <code>true</code>.
This global switch will cause adding modification flags to be stored for all audited properties of all audited entities.</p>
</li>
<li>
<p>using <code>@Audited( withModifiedFlag=true )</code> on a property or on an entity.</p>
</li>
</ol>
</div>
<div class="paragraph">
<p>The trade-off coming with this functionality is an increased size of audit tables and a very little, almost negligible, performance drop during audit writes.
This is due to the fact that every tracked property has to have an accompanying boolean column in the schema that stores information about the property modifications.
Of course it is Envers job to fill these columns accordingly - no additional work by the developer is required.
Because of costs mentioned, it is recommended to enable the feature selectively, when needed with use of the granular configuration means described above.</p>
</div>
<div id="envers-tracking-properties-changes-mapping-example" class="exampleblock">
<div class="title">Example 24. Mapping for tracking entity changes at property level</div>
<div class="content">
<div class="listingblock">
<div class="content">
<pre class="prettyprint highlight"><code class="language-JAVA" data-lang="JAVA">@Audited(withModifiedFlag = true)
@Entity(name = "Customer")
public static class Customer {

    @Id
    private Long id;

    private String firstName;

    private String lastName;

    @Temporal( TemporalType.TIMESTAMP )
    @Column(name = "created_on")
    @CreationTimestamp
    private Date createdOn;

    //Getters and setters are omitted for brevity
}</code></pre>
</div>
</div>
<div class="listingblock">
<div class="content">
<pre class="prettyprint highlight"><code class="language-SQL" data-lang="SQL">create table Customer_AUD (
    id bigint not null,
    REV integer not null,
    REVTYPE tinyint,
    created_on timestamp,
    createdOn_MOD boolean,
    firstName varchar(255),
    firstName_MOD boolean,
    lastName varchar(255),
    lastName_MOD boolean,
    primary key (id, REV)
)</code></pre>
</div>
</div>
</div>
</div>
<div class="paragraph">
<p>As you can see, every property features a <code>_MOD</code> column (e.g. <code>createdOn_MOD</code>) in the audit log.</p>
</div>
<div id="envers-tracking-properties-changes-example" class="exampleblock">
<div class="title">Example 25. Tracking entity changes at property level example</div>
<div class="content">
<div class="listingblock">
<div class="content">
<pre class="prettyprint highlight"><code class="language-JAVA" data-lang="JAVA">Customer customer = entityManager.find( Customer.class, 1L );
customer.setLastName( "Doe Jr." );</code></pre>
</div>
</div>
<div class="listingblock">
<div class="content">
<pre class="prettyprint highlight"><code class="language-SQL" data-lang="SQL">update
    Customer
set
    created_on = ?,
    firstName = ?,
    lastName = ?
where
    id = ?

-- binding parameter [1] as [TIMESTAMP] - [2017-07-31 15:58:20.342]
-- binding parameter [2] as [VARCHAR]   - [John]
-- binding parameter [3] as [VARCHAR]   - [Doe Jr.]
-- binding parameter [4] as [BIGINT]    - [1]

insert
into
    REVINFO
    (REV, REVTSTMP)
values
    (null, ?)

-- binding parameter [1] as [BIGINT] - [1501505900439]

insert
into
    Customer_AUD
    (REVTYPE, created_on, createdOn_MOD, firstName, firstName_MOD, lastName, lastName_MOD, id, REV)
values
    (?, ?, ?, ?, ?, ?, ?, ?, ?)

-- binding parameter [1] as [INTEGER]   - [1]
-- binding parameter [2] as [TIMESTAMP] - [2017-07-31 15:58:20.342]
-- binding parameter [3] as [BOOLEAN]   - [false]
-- binding parameter [4] as [VARCHAR]   - [John]
-- binding parameter [5] as [BOOLEAN]   - [false]
-- binding parameter [6] as [VARCHAR]   - [Doe Jr.]
-- binding parameter [7] as [BOOLEAN]   - [true]
-- binding parameter [8] as [BIGINT]    - [1]
-- binding parameter [9] as [INTEGER]   - [2]</code></pre>
</div>
</div>
</div>
</div>
<div class="paragraph">
<p>To see how "Modified Flags" can be utilized, check out the very simple query API that uses them: <a href="#envers-tracking-properties-changes-queries">Querying for revisions of entity that modified a given property</a>.</p>
</div>
</div>
<div class="sect2">
<h3 id="envers-queries">Queries</h3>
<div class="paragraph">
<p>You can think of historic data as having two dimensions:</p>
</div>
<div class="dlist">
<dl>
<dt class="hdlist1">horizontal</dt>
<dd>
<p>The state of the database at a given revision. Thus, you can query for entities as they were at revision N.</p>
</dd>
<dt class="hdlist1">vertical</dt>
<dd>
<p>The revisions, at which entities changed. Hence, you can query for revisions, in which a given entity changed.</p>
</dd>
</dl>
</div>
<div class="paragraph">
<p>The queries in Envers are similar to Hibernate Criteria queries, so if you are common with them, using Envers queries will be much easier.</p>
</div>
<div class="paragraph">
<p>The main limitation of the current queries implementation is that you cannot traverse relations.
You can only specify constraints on the ids of the related entities, and only on the "owning" side of the relation.
This however will be changed in future releases.</p>
</div>
<div class="admonitionblock note">
<table>
<tr>
<td class="icon">
<i class="fa icon-note" title="Note"></i>
</td>
<td class="content">
<div class="paragraph">
<p>The queries on the audited data will be in many cases much slower than corresponding queries on "live" data,
as, especially for the default audit strategy, they involve correlated subselects.</p>
</div>
<div class="paragraph">
<p>Queries are improved both in terms of speed and possibilities, when using the validity audit strategy,
which stores both start and end revisions for entities. See <a href="#envers-audit-ValidityAuditStrategy">Configuring the <code>ValidityAuditStrategy</code></a>.</p>
</div>
</td>
</tr>
</table>
</div>
</div>
<div class="sect2">
<h3 id="entities-at-revision">Querying for entities of a class at a given revision</h3>
<div class="paragraph">
<p>The entry point for this type of queries is:</p>
</div>
<div id="entities-at-revision-example" class="exampleblock">
<div class="title">Example 26. Getting the <code>Customer</code> entity at a given revision</div>
<div class="content">
<div class="listingblock">
<div class="content">
<pre class="prettyprint highlight"><code class="language-JAVA" data-lang="JAVA">Customer customer = (Customer) AuditReaderFactory
.get( entityManager )
.createQuery()
.forEntitiesAtRevision( Customer.class, revisions.get( 0 ) )
.getSingleResult();

assertEquals("Doe", customer.getLastName());</code></pre>
</div>
</div>
</div>
</div>
</div>
<div class="sect2">
<h3 id="entities-filtering">Querying for entities using filtering criteria</h3>
<div class="paragraph">
<p>You can then specify constraints, which should be met by the entities returned, by adding restrictions,
which can be obtained using the <code>AuditEntity</code> factory class.</p>
</div>
<div class="paragraph">
<p>For example, to select only entities where the <code>firstName</code> property is equal to "John":</p>
</div>
<div id="entities-filtering-example" class="exampleblock">
<div class="title">Example 27. Getting the <code>Customer</code> audit log with a given <code>firstName</code> attribute value</div>
<div class="content">
<div class="listingblock">
<div class="content">
<pre class="prettyprint highlight"><code class="language-JAVA" data-lang="JAVA">List&lt;Customer&gt; customers = AuditReaderFactory
.get( entityManager )
.createQuery()
.forRevisionsOfEntity( Customer.class, true, true )
.add( AuditEntity.property( "firstName" ).eq( "John" ) )
.getResultList();

assertEquals(2, customers.size());
assertEquals( "Doe", customers.get( 0 ).getLastName() );
assertEquals( "Doe Jr.", customers.get( 1 ).getLastName() );</code></pre>
</div>
</div>
</div>
</div>
<div class="paragraph">
<p>And, to select only entities whose relationships are related to a given entity,
you can use either the target entity or its identifier.</p>
</div>
<div id="entities-filtering-by-entity-example" class="exampleblock">
<div class="title">Example 28. Getting the <code>Customer</code> entities whose <code>address</code> attribute matches the given entity reference</div>
<div class="content">
<div class="listingblock">
<div class="content">
<pre class="prettyprint highlight"><code class="language-JAVA" data-lang="JAVA">Address address = entityManager.getReference( Address.class, 1L );

List&lt;Customer&gt; customers = AuditReaderFactory
.get( entityManager )
.createQuery()
.forRevisionsOfEntity( Customer.class, true, true )
.add( AuditEntity.property( "address" ).eq( address ) )
.getResultList();

assertEquals(2, customers.size());</code></pre>
</div>
</div>
<div class="listingblock">
<div class="content">
<pre class="prettyprint highlight"><code class="language-SQL" data-lang="SQL">select
    c.id as id1_3_,
    c.REV as REV2_3_,
    c.REVTYPE as REVTYPE3_3_,
    c.REVEND as REVEND4_3_,
    c.created_on as created_5_3_,
    c.firstName as firstNam6_3_,
    c.lastName as lastName7_3_,
    c.address_id as address_8_3_
from
    Customer_AUD c
where
    c.address_id = ?
order by
    c.REV asc

-- binding parameter [1] as [BIGINT] - [1]</code></pre>
</div>
</div>
</div>
</div>
<div class="paragraph">
<p>The same SQL is generated even if we provide the identifier instead of the target entity reference.</p>
</div>
<div id="entities-filtering-by-entity-identifier-example" class="exampleblock">
<div class="title">Example 29. Getting the <code>Customer</code> entities whose <code>address</code> identifier matches the given entity identifier</div>
<div class="content">
<div class="listingblock">
<div class="content">
<pre class="prettyprint highlight"><code class="language-JAVA" data-lang="JAVA">List&lt;Customer&gt; customers = AuditReaderFactory
.get( entityManager )
.createQuery()
.forRevisionsOfEntity( Customer.class, true, true )
.add( AuditEntity.relatedId( "address" ).eq( 1L ) )
.getResultList();

assertEquals(2, customers.size());</code></pre>
</div>
</div>
</div>
</div>
<div class="paragraph">
<p>Apart for strict equality matching, you can also use an <code>IN</code> clause to provide multiple entity identifiers:</p>
</div>
<div id="entities-in-clause-filtering-by-entity-identifier-example" class="exampleblock">
<div class="title">Example 30. Getting the <code>Customer</code> entities whose <code>address</code> identifier matches one of the given entity identifiers</div>
<div class="content">
<div class="listingblock">
<div class="content">
<pre class="prettyprint highlight"><code class="language-JAVA" data-lang="JAVA">List&lt;Customer&gt; customers = AuditReaderFactory
.get( entityManager )
.createQuery()
.forRevisionsOfEntity( Customer.class, true, true )
.add( AuditEntity.relatedId( "address" ).in( new Object[] { 1L, 2L } ) )
.getResultList();

assertEquals(2, customers.size());</code></pre>
</div>
</div>
<div class="listingblock">
<div class="content">
<pre class="prettyprint highlight"><code class="language-SQL" data-lang="SQL">select
    c.id as id1_3_,
    c.REV as REV2_3_,
    c.REVTYPE as REVTYPE3_3_,
    c.REVEND as REVEND4_3_,
    c.created_on as created_5_3_,
    c.firstName as firstNam6_3_,
    c.lastName as lastName7_3_,
    c.address_id as address_8_3_
from
    Customer_AUD c
where
    c.address_id in (
        ? , ?
    )
order by
    c.REV asc

-- binding parameter [1] as [BIGINT] - [1]
-- binding parameter [2] as [BIGINT] - [2]</code></pre>
</div>
</div>
</div>
</div>
<div class="paragraph">
<p>You can limit the number of results, order them, and set aggregations and projections (except grouping) in the usual way.
When your query is complete, you can obtain the results by calling the <code>getSingleResult()</code> or <code>getResultList()</code> methods.</p>
</div>
<div class="paragraph">
<p>A full query, can look for example like this:</p>
</div>
<div id="entities-filtering-and-pagination" class="exampleblock">
<div class="title">Example 31. Getting the <code>Customer</code> entities using filtering and pagination</div>
<div class="content">
<div class="listingblock">
<div class="content">
<pre class="prettyprint highlight"><code class="language-JAVA" data-lang="JAVA">List&lt;Customer&gt; customers = AuditReaderFactory
.get( entityManager )
.createQuery()
.forRevisionsOfEntity( Customer.class, true, true )
.addOrder( AuditEntity.property( "lastName" ).desc() )
.add( AuditEntity.relatedId( "address" ).eq( 1L ) )
.setFirstResult( 1 )
.setMaxResults( 2 )
.getResultList();

assertEquals(1, customers.size());</code></pre>
</div>
</div>
<div class="listingblock">
<div class="content">
<pre class="prettyprint highlight"><code class="language-SQL" data-lang="SQL">select
    c.id as id1_3_,
    c.REV as REV2_3_,
    c.REVTYPE as REVTYPE3_3_,
    c.REVEND as REVEND4_3_,
    c.created_on as created_5_3_,
    c.firstName as firstNam6_3_,
    c.lastName as lastName7_3_,
    c.address_id as address_8_3_
from
    Customer_AUD c
where
    c.address_id = ?
order by
    c.lastName desc
limit ?
offset ?</code></pre>
</div>
</div>
</div>
</div>
</div>
<div class="sect2">
<h3 id="revisions-of-entity">Querying for revisions, at which entities of a given class changed</h3>
<div class="paragraph">
<p>The entry point for this type of queries is:</p>
</div>
<div id="revisions-of-entity-query-example" class="listingblock">
<div class="content">
<pre class="prettyprint highlight"><code class="language-JAVA" data-lang="JAVA">AuditQuery query = AuditReaderFactory.get( entityManager )
    .createQuery()
    .forRevisionsOfEntity( Customer.class, false, true );</code></pre>
</div>
</div>
<div class="paragraph">
<p>You can add constraints to this query in the same way as to the previous one.</p>
</div>
<div class="paragraph">
<p>There are some additional possibilities:</p>
</div>
<div class="olist arabic">
<ol class="arabic">
<li>
<p>using <code>AuditEntity.revisionNumber()</code> you can specify constraints, projections and order on the revision number, in which the audited entity was modified</p>
</li>
<li>
<p>similarly, using <code>AuditEntity.revisionProperty( propertyName )</code> you can specify constraints, projections and order on a property of the revision entity,
corresponding to the revision in which the audited entity was modified</p>
</li>
<li>
<p><code>AuditEntity.revisionType()</code> gives you access as above to the type of the revision (<code>ADD</code>, <code>MOD</code>, <code>DEL</code>).</p>
</li>
</ol>
</div>
<div class="paragraph">
<p>Using these methods, you can order the query results by revision number, set projection or constraint the revision number to be greater or less than a specified value, etc.
For example, the following query will select the smallest revision number, at which entity of class <code>MyEntity</code> with id <code>entityId</code> has changed, after revision number 2:</p>
</div>
<div id="revisions-of-entity-query-by-revision-number-example" class="listingblock">
<div class="content">
<pre class="prettyprint highlight"><code class="language-JAVA" data-lang="JAVA">Number revision = (Number) AuditReaderFactory
.get( entityManager )
.createQuery()
.forRevisionsOfEntity( Customer.class, false, true )
.addProjection( AuditEntity.revisionNumber().min() )
.add( AuditEntity.id().eq( 1L ) )
.add( AuditEntity.revisionNumber().gt( 2 ) )
.getSingleResult();</code></pre>
</div>
</div>
<div class="paragraph">
<p>The second additional feature you can use in queries for revisions is the ability to <em>maximize</em>/<em>minimize</em> a property.</p>
</div>
<div class="paragraph">
<p>For example, if you want to select the smallest possibler revision at which the value of the <code>createdOn</code>
attribute was larger then a given value,
you can run the following query:</p>
</div>
<div id="revisions-of-entity-query-minimize-example" class="listingblock">
<div class="content">
<pre class="prettyprint highlight"><code class="language-JAVA" data-lang="JAVA">Number revision = (Number) AuditReaderFactory
.get( entityManager )
.createQuery()
.forRevisionsOfEntity( Customer.class, false, true )
.addProjection( AuditEntity.revisionNumber().min() )
.add( AuditEntity.id().eq( 1L ) )
.add(
    AuditEntity.property( "createdOn" )
    .minimize()
    .add( AuditEntity.property( "createdOn" )
        .ge(
            Timestamp.from(
                LocalDateTime.now()
                    .minusDays( 1 )
                    .toInstant( ZoneOffset.UTC )
                )
        )
    )
)
.getSingleResult();</code></pre>
</div>
</div>
<div class="paragraph">
<p>The <code>minimize()</code> and <code>maximize()</code> methods return a criteria, to which you can add constraints,
which must be met by the entities with the <em>maximized</em>/<em>minimized</em> properties.</p>
</div>
<div class="paragraph">
<p>You probably also noticed that there are two boolean parameters, passed when creating the query.</p>
</div>
<div class="dlist">
<dl>
<dt class="hdlist1"><code>selectEntitiesOnly</code></dt>
<dd>
<p>The first parameter is only valid when you don&#8217;t set an explicit projection.</p>
<div class="paragraph">
<p>If true, the result of the query will be a list of entities (which changed at revisions satisfying the specified constraints).</p>
</div>
<div class="paragraph">
<p>If false, the result will be a list of three element arrays:</p>
</div>
<div class="ulist">
<ul>
<li>
<p>the first element will be the changed entity instance.</p>
</li>
<li>
<p>the second will be an entity containing revision data (if no custom entity is used, this will be an instance of <code>DefaultRevisionEntity</code>).</p>
</li>
<li>
<p>the third will be the type of the revision (one of the values of the <code>RevisionType</code> enumeration: <code>ADD</code>, <code>MOD</code>, <code>DEL</code>).</p>
</li>
</ul>
</div>
</dd>
<dt class="hdlist1"><code>selectDeletedEntities</code></dt>
<dd>
<p>The second parameter specifies if revisions,
in which the entity was deleted should be included in the results.</p>
<div class="paragraph">
<p>If yes, such entities will have the revision type <code>DEL</code> and all attributes, except the <code>id</code>, will be set to <code>null</code>.</p>
</div>
</dd>
</dl>
</div>
<div class="paragraph">
<p>Another useful feature is <code>AggregatedAuditExpression#computeAggregationInInstanceContext()</code>.  This can be used to create
an aggregate query based on the entity instance primary key.</p>
</div>
<div class="paragraph">
<p>For example, if you wanted to locate all customers but only wanted to retrieve the instances with the
maximum revision number, you would use the following query:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="prettyprint highlight"><code class="language-JAVA" data-lang="JAVA">List&lt;Customer&gt; results = AuditReaderFactory
    .get( entityManager )
    .createQuery()
    .forRevisionsOfEntity( Customer.class, true, false )
    .add( AuditEntity.revisionNumber().maximize().computeAggregationInInstanceContext() )
    .getResultList();</code></pre>
</div>
</div>
<div class="paragraph">
<p>In other words, the result set would contain a list of <code>Customer</code> instances, one per primary key.  Each instance would
hold the audited property data at the <em>maximum</em> revision number for each <code>Customer</code> primary key.</p>
</div>
</div>
<div class="sect2">
<h3 id="envers-tracking-properties-changes-queries">Querying for revisions of entity that modified a given property</h3>
<div class="paragraph">
<p>For the two types of queries described above it&#8217;s possible to use special <code>Audit</code> criteria called <code>hasChanged()</code> and <code>hasNotChanged()</code>
that makes use of the functionality described in <a href="#envers-tracking-properties-changes">Tracking entity changes at property level</a>.</p>
</div>
<div class="paragraph">
<p>Let&#8217;s have a look at various queries that can benefit from these two criteria.</p>
</div>
<div class="paragraph">
<p>First, you must make sure that your entity can track <em>modification flags</em>:</p>
</div>
<div id="envers-tracking-properties-changes-queries-entity-example" class="exampleblock">
<div class="title">Example 32. Valid only when audit logging tracks entity attribute modification flags</div>
<div class="content">
<div class="listingblock">
<div class="content">
<pre class="prettyprint highlight"><code class="language-JAVA" data-lang="JAVA">@Audited( withModifiedFlag = true )</code></pre>
</div>
</div>
</div>
</div>
<div class="paragraph">
<p>The following query will return all revisions of the <code>Customer</code> entity with the given <code>id</code>,
for which the <code>lastName</code> property has changed.</p>
</div>
<div id="envers-tracking-properties-changes-queries-hasChanged-example" class="exampleblock">
<div class="title">Example 33. Getting all <code>Customer</code> revisions for which the <code>lastName</code> attribute has changed</div>
<div class="content">
<div class="listingblock">
<div class="content">
<pre class="prettyprint highlight"><code class="language-JAVA" data-lang="JAVA">List&lt;Customer&gt; customers = AuditReaderFactory
.get( entityManager )
.createQuery()
.forRevisionsOfEntity( Customer.class, false, true )
.add( AuditEntity.id().eq( 1L ) )
.add( AuditEntity.property( "lastName" ).hasChanged() )
.getResultList();</code></pre>
</div>
</div>
<div class="listingblock">
<div class="content">
<pre class="prettyprint highlight"><code class="language-SQL" data-lang="SQL">select
    c.id as id1_3_0_,
    c.REV as REV2_3_0_,
    defaultrev1_.REV as REV1_4_1_,
    c.REVTYPE as REVTYPE3_3_0_,
    c.REVEND as REVEND4_3_0_,
    c.created_on as created_5_3_0_,
    c.createdOn_MOD as createdO6_3_0_,
    c.firstName as firstNam7_3_0_,
    c.firstName_MOD as firstNam8_3_0_,
    c.lastName as lastName9_3_0_,
    c.lastName_MOD as lastNam10_3_0_,
    c.address_id as address11_3_0_,
    c.address_MOD as address12_3_0_,
    defaultrev1_.REVTSTMP as REVTSTMP2_4_1_
from
    Customer_AUD c cross
join
    REVINFO defaultrev1_
where
    c.id = ?
    and c.lastName_MOD = ?
    and c.REV=defaultrev1_.REV
order by
    c.REV asc

-- binding parameter [1] as [BIGINT]  - [1]
-- binding parameter [2] as [BOOLEAN] - [true]</code></pre>
</div>
</div>
</div>
</div>
<div class="paragraph">
<p>Using this query we won&#8217;t get all other revisions in which <code>lastName</code> wasn&#8217;t touched.
From the SQL query you can see that the <code>lastName_MOD</code> column is being used in the WHERE clause,
hence the aforementioned requirement for tracking modification flags.</p>
</div>
<div class="paragraph">
<p>Of course, nothing prevents user from combining <code>hasChanged</code> condition with some additional criteria.</p>
</div>
<div id="envers-tracking-properties-changes-queries-hasChanged-and-hasNotChanged-example" class="exampleblock">
<div class="title">Example 34. Getting all <code>Customer</code> revisions for which the <code>lastName</code> attribute has changed and the <code>firstName</code> attribute has not changed</div>
<div class="content">
<div class="listingblock">
<div class="content">
<pre class="prettyprint highlight"><code class="language-JAVA" data-lang="JAVA">List&lt;Customer&gt; customers = AuditReaderFactory
.get( entityManager )
.createQuery()
.forRevisionsOfEntity( Customer.class, false, true )
.add( AuditEntity.id().eq( 1L ) )
.add( AuditEntity.property( "lastName" ).hasChanged() )
.add( AuditEntity.property( "firstName" ).hasNotChanged() )
.getResultList();</code></pre>
</div>
</div>
<div class="listingblock">
<div class="content">
<pre class="prettyprint highlight"><code class="language-SQL" data-lang="SQL">select
    c.id as id1_3_0_,
    c.REV as REV2_3_0_,
    defaultrev1_.REV as REV1_4_1_,
    c.REVTYPE as REVTYPE3_3_0_,
    c.REVEND as REVEND4_3_0_,
    c.created_on as created_5_3_0_,
    c.createdOn_MOD as createdO6_3_0_,
    c.firstName as firstNam7_3_0_,
    c.firstName_MOD as firstNam8_3_0_,
    c.lastName as lastName9_3_0_,
    c.lastName_MOD as lastNam10_3_0_,
    c.address_id as address11_3_0_,
    c.address_MOD as address12_3_0_,
    defaultrev1_.REVTSTMP as REVTSTMP2_4_1_
from
    Customer_AUD c cross
join
    REVINFO defaultrev1_
where
    c.id=?
    and c.lastName_MOD=?
    and c.firstName_MOD=?
    and c.REV=defaultrev1_.REV
order by
    c.REV asc

-- binding parameter [1] as [BIGINT]  - [1]
-- binding parameter [2] as [BOOLEAN] - [true]
-- binding parameter [3] as [BOOLEAN] - [false]</code></pre>
</div>
</div>
</div>
</div>
<div class="paragraph">
<p>To get the <code>Customer</code> entities changed at a given <code>revisionNumber</code> with <code>lastName</code> modified and <code>firstName</code> untouched,
we have to use the <code>forEntitiesModifiedAtRevision</code> query:</p>
</div>
<div id="envers-tracking-properties-changes-queries-at-revision-example" class="exampleblock">
<div class="title">Example 35. Getting the <code>Customer</code> entity for a given revision if the <code>lastName</code> attribute has changed and the <code>firstName</code> attribute has not changed</div>
<div class="content">
<div class="listingblock">
<div class="content">
<pre class="prettyprint highlight"><code class="language-JAVA" data-lang="JAVA">Customer customer = (Customer) AuditReaderFactory
.get( entityManager )
.createQuery()
.forEntitiesModifiedAtRevision( Customer.class, 2 )
.add( AuditEntity.id().eq( 1L ) )
.add( AuditEntity.property( "lastName" ).hasChanged() )
.add( AuditEntity.property( "firstName" ).hasNotChanged() )
.getSingleResult();</code></pre>
</div>
</div>
<div class="listingblock">
<div class="content">
<pre class="prettyprint highlight"><code class="language-SQL" data-lang="SQL">select
    c.id as id1_3_,
    c.REV as REV2_3_,
    c.REVTYPE as REVTYPE3_3_,
    c.REVEND as REVEND4_3_,
    c.created_on as created_5_3_,
    c.createdOn_MOD as createdO6_3_,
    c.firstName as firstNam7_3_,
    c.firstName_MOD as firstNam8_3_,
    c.lastName as lastName9_3_,
    c.lastName_MOD as lastNam10_3_,
    c.address_id as address11_3_,
    c.address_MOD as address12_3_
from
    Customer_AUD c
where
    c.REV=?
    and c.id=?
    and c.lastName_MOD=?
    and c.firstName_MOD=?

-- binding parameter [1] as [INTEGER] - [2]
-- binding parameter [2] as [BIGINT]  - [1]
-- binding parameter [3] as [BOOLEAN] - [true]
-- binding parameter [4] as [BOOLEAN] - [false]</code></pre>
</div>
</div>
</div>
</div>
</div>
<div class="sect2">
<h3 id="envers-tracking-modified-entities-queries">Querying for entity types modified in a given revision</h3>
<div class="admonitionblock note">
<table>
<tr>
<td class="icon">
<i class="fa icon-note" title="Note"></i>
</td>
<td class="content">
<div class="paragraph">
<p>The methods described below can be used only when the default mechanism of tracking changed entity types is enabled (see <a href="#envers-tracking-modified-entities-revchanges">Tracking entity names modified during revisions</a>).</p>
</div>
</td>
</tr>
</table>
</div>
<div class="paragraph">
<p>This basic query allows retrieving entity names and corresponding Java classes changed in a specified revision:</p>
</div>
<div id="envers-tracking-modified-entities-queries-example" class="exampleblock">
<div class="title">Example 36. Retrieving entity names and corresponding Java classes changed in a specified revision</div>
<div class="content">
<div class="listingblock">
<div class="content">
<pre class="prettyprint highlight"><code class="language-JAVA" data-lang="JAVA">assertEquals(
    "org.hibernate.userguide.envers.EntityTypeChangeAuditTest$Customer",
    AuditReaderFactory
    .get( entityManager )
    .getCrossTypeRevisionChangesReader()
    .findEntityTypes( 1 )
    .iterator().next()
    .getFirst()
);

assertEquals(
    "org.hibernate.userguide.envers.EntityTypeChangeAuditTest$ApplicationCustomer",
    AuditReaderFactory
    .get( entityManager )
    .getCrossTypeRevisionChangesReader()
    .findEntityTypes( 2 )
    .iterator().next()
    .getFirst()
);</code></pre>
</div>
</div>
</div>
</div>
<div class="paragraph">
<p>Other queries (also accessible from <code>org.hibernate.envers.CrossTypeRevisionChangesReader</code>):</p>
</div>
<div class="dlist">
<dl>
<dt class="hdlist1"><code>List&lt;Object&gt; findEntities( Number )</code></dt>
<dd>
<p>Returns snapshots of all audited entities changed (added, updated and removed) in a given revision.
Executes <code>N+1</code> SQL queries, where <code>N</code> is a number of different entity classes modified within specified revision.</p>
</dd>
<dt class="hdlist1"><code>List&lt;Object&gt; findEntities( Number, RevisionType )</code></dt>
<dd>
<p>Returns snapshots of all audited entities changed (added, updated or removed) in a given revision filtered by modification type.
Executes <code>N+1</code> SQL queries, where <code>N</code> is a number of different entity classes modified within specified revision.</p>
</dd>
<dt class="hdlist1"><code>Map&lt;RevisionType, List&lt;Object&gt;&gt; findEntitiesGroupByRevisionType( Number )</code></dt>
<dd>
<p>Returns a map containing lists of entity snapshots grouped by modification operation (e.g. addition, update and removal).
Executes <code>3N+1</code> SQL queries, where <code>N</code> is a number of different entity classes modified within specified revision.</p>
</dd>
</dl>
</div>
</div>
<div class="sect2">
<h3 id="envers-querying-entity-relation-joins">Querying for entities using entity relation joins</h3>
<div class="admonitionblock warning">
<table>
<tr>
<td class="icon">
<i class="fa icon-warning" title="Warning"></i>
</td>
<td class="content">
<div class="paragraph">
<p>Relation join queries are considered experimental and may change in future releases.</p>
</div>
</td>
</tr>
</table>
</div>
<div class="paragraph">
<p>Audit queries support the ability to apply constraints, projections, and sort operations based on entity relations.  In order
to traverse entity relations through an audit query, you must use the relation traversal API with a join type.</p>
</div>
<div class="admonitionblock note">
<table>
<tr>
<td class="icon">
<i class="fa icon-note" title="Note"></i>
</td>
<td class="content">
<div class="paragraph">
<p>Relation joins can be applied to <code>many-to-one</code> and <code>many-to-one</code> mappings only when using <code>JoinType.LEFT</code> or <code>JoinType.INNER</code>.</p>
</div>
</td>
</tr>
</table>
</div>
<div class="paragraph">
<p>The basis for creating an entity relation join query is as follows:</p>
</div>
<div id="envers-querying-entity-relation-inner-join" class="exampleblock">
<div class="title">Example 37. INNER JOIN entity audit query</div>
<div class="content">
<div class="listingblock">
<div class="content">
<pre class="prettyprint highlight"><code class="language-JAVA" data-lang="JAVA">AuditQuery innerJoinAuditQuery = AuditReaderFactory
.get( entityManager )
.createQuery()
.forEntitiesAtRevision( Customer.class, 1 )
.traverseRelation( "address", JoinType.INNER );</code></pre>
</div>
</div>
</div>
</div>
<div id="envers-querying-entity-relation-left-join" class="exampleblock">
<div class="title">Example 38. LEFT JOIN entity audit query</div>
<div class="content">
<div class="listingblock">
<div class="content">
<pre class="prettyprint highlight"><code class="language-JAVA" data-lang="JAVA">AuditQuery innerJoinAuditQuery = AuditReaderFactory
.get( entityManager )
.createQuery()
.forEntitiesAtRevision( Customer.class, 1 )
.traverseRelation( "address", JoinType.LEFT );</code></pre>
</div>
</div>
</div>
</div>
<div class="paragraph">
<p>Like any other query, constraints may be added to restrict the results.</p>
</div>
<div class="paragraph">
<p>For example, to find a <code>Customers</code> entities at a given revision whose addresses are in <code>România</code>,
you can use the following query:</p>
</div>
<div id="envers-querying-entity-relation-join-restriction" class="exampleblock">
<div class="title">Example 39. Filtering the join relation with a WHERE clause predicate</div>
<div class="content">
<div class="listingblock">
<div class="content">
<pre class="prettyprint highlight"><code class="language-JAVA" data-lang="JAVA">List&lt;Customer&gt; customers = AuditReaderFactory
.get( entityManager )
.createQuery()
.forEntitiesAtRevision( Customer.class, 1 )
.traverseRelation( "address", JoinType.INNER )
.add( AuditEntity.property( "country" ).eq( "România" ) )
.getResultList();</code></pre>
</div>
</div>
<div class="listingblock">
<div class="content">
<pre class="prettyprint highlight"><code class="language-SQL" data-lang="SQL">select
    c.id as id1_3_,
    c.REV as REV2_3_,
    c.REVTYPE as REVTYPE3_3_,
    c.REVEND as REVEND4_3_,
    c.created_on as created_5_3_,
    c.firstName as firstNam6_3_,
    c.lastName as lastName7_3_,
    c.address_id as address_8_3_
from
    Customer_AUD c
inner join
    Address_AUD a
        on (
            c.address_id=a.id
            or (
                c.address_id is null
            )
            and (
                a.id is null
            )
        )
where
    c.REV&lt;=?
    and c.REVTYPE&lt;&gt;?
    and (
        c.REVEND&gt;?
        or c.REVEND is null
    )
    and a.REV&lt;=?
    and a.country=?
    and (
        a.REVEND&gt;?
        or a.REVEND is null
    )

-- binding parameter [1] as [INTEGER] - [1]
-- binding parameter [2] as [INTEGER] - [2]
-- binding parameter [3] as [INTEGER] - [1]
-- binding parameter [4] as [INTEGER] - [1]
-- binding parameter [5] as [VARCHAR] - [România]
-- binding parameter [6] as [INTEGER] - [1]</code></pre>
</div>
</div>
</div>
</div>
<div class="paragraph">
<p>It is also possible to traverse beyond the first relation in an entity graph.</p>
</div>
<div class="paragraph">
<p>For example, to find all <code>Customer</code> entities at a given revision
with the country attribute of the address property being <code>România</code>:</p>
</div>
<div id="envers-querying-entity-relation-nested-join-restriction" class="exampleblock">
<div class="title">Example 40. Filtering a nested join relation with a WHERE clause predicate</div>
<div class="content">
<div class="listingblock">
<div class="content">
<pre class="prettyprint highlight"><code class="language-JAVA" data-lang="JAVA">List&lt;Customer&gt; customers = AuditReaderFactory
.get( entityManager )
.createQuery()
.forEntitiesAtRevision( Customer.class, 1 )
.traverseRelation( "address", JoinType.INNER )
.traverseRelation( "country", JoinType.INNER )
.add( AuditEntity.property( "name" ).eq( "România" ) )
.getResultList();

assertEquals( 1, customers.size() );</code></pre>
</div>
</div>
<div class="listingblock">
<div class="content">
<pre class="prettyprint highlight"><code class="language-SQL" data-lang="SQL">select
    cu.id as id1_5_,
    cu.REV as REV2_5_,
    cu.REVTYPE as REVTYPE3_5_,
    cu.REVEND as REVEND4_5_,
    cu.created_on as created_5_5_,
    cu.firstName as firstNam6_5_,
    cu.lastName as lastName7_5_,
    cu.address_id as address_8_5_
from
    Customer_AUD cu
inner join
    Address_AUD a
        on (
            cu.address_id=a.id
            or (
                cu.address_id is null
            )
            and (
                a.id is null
            )
        )
inner join
    Country_AUD co
        on (
            a.country_id=co.id
            or (
                a.country_id is null
            )
            and (
                co.id is null
            )
        )
where
    cu.REV&lt;=?
    and cu.REVTYPE&lt;&gt;?
    and (
        cu.REVEND&gt;?
        or cu.REVEND is null
    )
    and a.REV&lt;=?
    and (
        a.REVEND&gt;?
        or a.REVEND is null
    )
    and co.REV&lt;=?
    and co.name=?
    and (
        co.REVEND&gt;?
        or co.REVEND is null
    )

-- binding parameter [1] as [INTEGER] - [1]
-- binding parameter [2] as [INTEGER] - [2]
-- binding parameter [3] as [INTEGER] - [1]
-- binding parameter [4] as [INTEGER] - [1]
-- binding parameter [5] as [INTEGER] - [1]
-- binding parameter [6] as [INTEGER] - [1]
-- binding parameter [7] as [VARCHAR] - [România]
-- binding parameter [8] as [INTEGER] - [1]</code></pre>
</div>
</div>
</div>
</div>
<div class="paragraph">
<p>Constraints may also be added to the properties of nested joined relations, such as testing for <code>null</code>.</p>
</div>
<div class="paragraph">
<p>For example, the following query illustrates how to find all <code>Customer</code> entities at a given revision
having the <code>address</code> in <code>Cluj-Napoca</code> or the <code>address</code> does <em>not</em> have any country entity reference:</p>
</div>
<div id="envers-querying-entity-relation-join-multiple-restrictions" class="exampleblock">
<div class="title">Example 41. Filtering a join relation using multiple predicates</div>
<div class="content">
<div class="listingblock">
<div class="content">
<pre class="prettyprint highlight"><code class="language-JAVA" data-lang="JAVA">List&lt;Customer&gt; customers = AuditReaderFactory
.get( entityManager )
.createQuery()
.forEntitiesAtRevision( Customer.class, 1 )
.traverseRelation( "address", JoinType.LEFT, "a" )
.add(
    AuditEntity.or(
        AuditEntity.property( "a", "city" ).eq( "Cluj-Napoca" ),
        AuditEntity.relatedId( "country" ).eq( null )
    )
)
.getResultList();</code></pre>
</div>
</div>
<div class="listingblock">
<div class="content">
<pre class="prettyprint highlight"><code class="language-SQL" data-lang="SQL">select
  c.id as id1_5_,
  c.REV as REV2_5_,
  c.REVTYPE as REVTYPE3_5_,
  c.REVEND as REVEND4_5_,
  c.created_on as created_5_5_,
  c.firstName as firstNam6_5_,
  c.lastName as lastName7_5_,
  c.address_id as address_8_5_
from
  Customer_AUD c
left outer join
  Address_AUD a
    on (
      c.address_id=a.id
      or (
        c.address_id is null
      )
      and (
        a.id is null
      )
    )
where
  c.REV&lt;=?
  and c.REVTYPE&lt;&gt;?
  and (
    c.REVEND&gt;?
    or c.REVEND is null
  )
  and (
    a.REV is null
    or a.REV&lt;=?
    and (
      a.REVEND&gt;?
      or a.REVEND is null
    )
  )
  and (
    a.city=?
    or a.country_id is null
  )

-- binding parameter [1] as [INTEGER] - [1]
-- binding parameter [2] as [INTEGER] - [2]
-- binding parameter [3] as [INTEGER] - [1]
-- binding parameter [4] as [INTEGER] - [1]
-- binding parameter [5] as [INTEGER] - [1]
-- binding parameter [6] as [VARCHAR] - [Cluj-Napoca]</code></pre>
</div>
</div>
</div>
</div>
<div class="admonitionblock note">
<table>
<tr>
<td class="icon">
<i class="fa icon-note" title="Note"></i>
</td>
<td class="content">
<div class="paragraph">
<p>Queries can use the <code>up</code> method to navigate back up the entity graph.</p>
</div>
</td>
</tr>
</table>
</div>
<div class="paragraph">
<p>Disjunction criterion may also be applied to relation join queries.</p>
</div>
<div class="paragraph">
<p>For example, the following query will find all <code>Customer</code> entities at a given revision
where the country name is <code>România</code> or that the <code>Customer</code> lives in <code>Cluj-Napoca</code>:</p>
</div>
<div id="envers-querying-entity-relation-nested-join-multiple-restrictions" class="exampleblock">
<div class="title">Example 42. Filtering a nested join relation using multiple predicates</div>
<div class="content">
<div class="listingblock">
<div class="content">
<pre class="prettyprint highlight"><code class="language-JAVA" data-lang="JAVA">List&lt;Customer&gt; customers = AuditReaderFactory
.get( entityManager )
.createQuery()
.forEntitiesAtRevision( Customer.class, 1 )
.traverseRelation( "address", JoinType.INNER, "a" )
.traverseRelation( "country", JoinType.INNER, "cn" )
.up()
.up()
.add(
    AuditEntity.disjunction()
    .add( AuditEntity.property( "a", "city" ).eq( "Cluj-Napoca" ) )
    .add( AuditEntity.property( "cn", "name" ).eq( "România" ) )
)
.addOrder( AuditEntity.property( "createdOn" ).asc() )
.getResultList();</code></pre>
</div>
</div>
<div class="listingblock">
<div class="content">
<pre class="prettyprint highlight"><code class="language-SQL" data-lang="SQL">select
    cu.id as id1_5_,
    cu.REV as REV2_5_,
    cu.REVTYPE as REVTYPE3_5_,
    cu.REVEND as REVEND4_5_,
    cu.created_on as created_5_5_,
    cu.firstName as firstNam6_5_,
    cu.lastName as lastName7_5_,
    cu.address_id as address_8_5_
from
    Customer_AUD cu
inner join
    Address_AUD a
        on (
            cu.address_id=a.id
            or (
                cu.address_id is null
            )
            and (
                a.id is null
            )
        )
inner join
    Country_AUD co
        on (
            a.country_id=co.id
            or (
                a.country_id is null
            )
            and (
                co.id is null
            )
        )
where
    cu.REV&lt;=?
    and cu.REVTYPE&lt;&gt;?
    and (
        cu.REVEND&gt;?
        or cu.REVEND is null
    )
    and (
        a.city=?
        or co.name=?
    )
    and a.REV&lt;=?
    and (
        a.REVEND&gt;?
        or a.REVEND is null
    )
    and co.REV&lt;=?
    and (
        co.REVEND&gt;?
        or co.REVEND is null
    )
order by
    cu.created_on asc

-- binding parameter [1] as [INTEGER] - [1]
-- binding parameter [2] as [INTEGER] - [2]
-- binding parameter [3] as [INTEGER] - [1]
-- binding parameter [4] as [VARCHAR] - [Cluj-Napoca]
-- binding parameter [5] as [VARCHAR] - [România]
-- binding parameter [6] as [INTEGER] - [1]
-- binding parameter [7] as [INTEGER] - [1]
-- binding parameter [8] as [INTEGER] - [1]
-- binding parameter [9] as [INTEGER] - [1]</code></pre>
</div>
</div>
</div>
</div>
<div class="paragraph">
<p>Lastly, this example illustrates how related entity properties can be compared in a single constraint.</p>
</div>
<div class="paragraph">
<p>Assuming, the <code>Customer</code> and the <code>Address</code> were previously changed as follows:</p>
</div>
<div id="envers-querying-entity-relation-nested-join-multiple-restrictions-combined-entities" class="exampleblock">
<div class="title">Example 43. Changing the <code>Address</code> to match the <code>Country</code> name</div>
<div class="content">
<div class="listingblock">
<div class="content">
<pre class="prettyprint highlight"><code class="language-JAVA" data-lang="JAVA">Customer customer = entityManager.createQuery(
    "select c " +
    "from Customer c " +
    "join fetch c.address a " +
    "join fetch a.country " +
    "where c.id = :id", Customer.class )
.setParameter( "id", 1L )
.getSingleResult();

customer.setLastName( "Doe Sr." );

customer.getAddress().setCity(
    customer.getAddress().getCountry().getName()
);</code></pre>
</div>
</div>
</div>
</div>
<div class="paragraph">
<p>The following query shows how to find the <code>Customer</code> entities
where the <code>city</code> property of the <code>address</code> attribute equals the <code>name</code> of the associated <code>country</code> attribute.</p>
</div>
<div id="envers-querying-entity-relation-nested-join-multiple-restrictions-combined" class="exampleblock">
<div class="title">Example 44. Filtering a nested join relation using multiple predicates</div>
<div class="content">
<div class="listingblock">
<div class="content">
<pre class="prettyprint highlight"><code class="language-JAVA" data-lang="JAVA">List&lt;Number&gt; revisions = AuditReaderFactory.get( entityManager ).getRevisions(
    Customer.class,
    1L
);

List&lt;Customer&gt; customers = AuditReaderFactory
.get( entityManager )
.createQuery()
.forEntitiesAtRevision( Customer.class, revisions.get( revisions.size() - 1 ) )
.traverseRelation( "address", JoinType.INNER, "a" )
.traverseRelation( "country", JoinType.INNER, "cn" )
.up()
.up()
.add( AuditEntity.property( "a", "city" ).eqProperty( "cn", "name" ) )
.getResultList();</code></pre>
</div>
</div>
<div class="listingblock">
<div class="content">
<pre class="prettyprint highlight"><code class="language-SQL" data-lang="SQL">select
    cu.id as id1_5_,
    cu.REV as REV2_5_,
    cu.REVTYPE as REVTYPE3_5_,
    cu.REVEND as REVEND4_5_,
    cu.created_on as created_5_5_,
    cu.firstName as firstNam6_5_,
    cu.lastName as lastName7_5_,
    cu.address_id as address_8_5_
from
    Customer_AUD cu
inner join
    Address_AUD a
        on (
            cu.address_id=a.id
            or (
                cu.address_id is null
            )
            and (
                a.id is null
            )
        )
inner join
    Country_AUD cr
        on (
            a.country_id=cr.id
            or (
                a.country_id is null
            )
            and (
                cr.id is null
            )
        )
where
    cu.REV&lt;=?
    and cu.REVTYPE&lt;&gt;?
    and a.city=cr.name
    and (
        cu.REVEND&gt;?
        or cu.REVEND is null
    )
    and a.REV&lt;=?
    and (
        a.REVEND&gt;?
        or a.REVEND is null
    )
    and cr.REV&lt;=?
    and (
        cr.REVEND&gt;?
        or cr.REVEND is null
    )

-- binding parameter [1] as [INTEGER] - [2]
-- binding parameter [2] as [INTEGER] - [2]
-- binding parameter [3] as [INTEGER] - [2]
-- binding parameter [4] as [INTEGER] - [2]
-- binding parameter [5] as [INTEGER] - [2]
-- binding parameter [6] as [INTEGER] - [2]
-- binding parameter [7] as [INTEGER] - [2]</code></pre>
</div>
</div>
</div>
</div>
</div>
<div class="sect2">
<h3 id="envers-conditional-auditing">Conditional auditing</h3>
<div class="paragraph">
<p>Envers persists audit data in reaction to various Hibernate events (e.g. <code>post update</code>, <code>post insert</code>, and so on),
using a series of event listeners from the <code>org.hibernate.envers.event.spi</code> package.
By default, if the Envers jar is in the classpath, the event listeners are auto-registered with Hibernate.</p>
</div>
<div class="paragraph">
<p>Conditional auditing can be implemented by overriding some of the Envers event listeners.
To use customized Envers event listeners, the following steps are needed:</p>
</div>
<div class="olist arabic">
<ol class="arabic">
<li>
<p>Turn off automatic Envers event listeners registration by setting the <code>hibernate.envers.autoRegisterListeners</code> Hibernate property to <code>false</code>.</p>
</li>
<li>
<p>Create subclasses for appropriate event listeners.
For example, if you want to conditionally audit entity insertions, extend the <code>org.hibernate.envers.event.spi.EnversPostInsertEventListenerImpl</code> class.
Place the conditional-auditing logic in the subclasses, call the super method if auditing should be performed.</p>
</li>
<li>
<p>Create your own implementation of <code>org.hibernate.integrator.spi.Integrator</code>, similar to <code>org.hibernate.envers.boot.internal.EnversIntegrator</code>.
Use your event listener classes instead of the default ones.</p>
</li>
<li>
<p>For the integrator to be automatically used when Hibernate starts up, you will need to add a <code>META-INF/services/org.hibernate.integrator.spi.Integrator</code> file to your jar.
The file should contain the fully qualified name of the class implementing the interface.</p>
</li>
</ol>
</div>
<div class="admonitionblock note">
<table>
<tr>
<td class="icon">
<i class="fa icon-note" title="Note"></i>
</td>
<td class="content">
<div class="paragraph">
<p>The use of <code>hibernate.listeners.envers.autoRegister</code> has been deprecated.
A new configuration setting <code>hibernate.envers.autoRegisterListeners</code> should be used instead.</p>
</div>
</td>
</tr>
</table>
</div>
</div>
<div class="sect2">
<h3 id="envers-schema">Understanding the Envers Schema</h3>
<div class="paragraph">
<p>For each audited entity (that is, for each entity containing at least one audited field), an audit table is created.
By default, the audit table&#8217;s name is created by adding an "_AUD" suffix to the original table name,
but this can be overridden by specifying a different suffix/prefix in the configuration properties or per-entity using the <code>@org.hibernate.envers.AuditTable</code> annotation.</p>
</div>
<div class="paragraph">
<p>The audit table contains the following columns:</p>
</div>
<div class="dlist">
<dl>
<dt class="hdlist1">id</dt>
<dd>
<p><code>id</code> of the original entity (this can be more then one column in the case of composite primary keys)</p>
</dd>
<dt class="hdlist1">revision number</dt>
<dd>
<p>an integer, which matches to the revision number in the revision entity table.</p>
</dd>
<dt class="hdlist1">revision type</dt>
<dd>
<p>The <code>org.hibernate.envers.RevisionType</code> enumeration ordinal stating if the change represent an INSERT, UPDATE or DELETE.</p>
</dd>
<dt class="hdlist1">audited fields</dt>
<dd>
<p>properties from the original entity being audited</p>
</dd>
</dl>
</div>
<div class="paragraph">
<p>The primary key of the audit table is the combination of the original id of the entity and the revision number,
so there can be at most one historic entry for a given entity instance at a given revision.</p>
</div>
<div class="paragraph">
<p>The current entity data is stored in the original table and in the audit table.
This is a duplication of data, however as this solution makes the query system much more powerful, and as memory is cheap, hopefully this won&#8217;t be a major drawback for the users.</p>
</div>
<div class="paragraph">
<p>A row in the audit table with entity id <code>ID</code>, revision <code>N</code> and data <code>D</code> means: entity with id <code>ID</code> has data <code>D</code> from revision <code>N</code> upwards.
Hence, if we want to find an entity at revision <code>M</code>, we have to search for a row in the audit table, which has the revision number smaller or equal to <code>M</code>, but as large as possible.
If no such row is found, or a row with a "deleted" marker is found, it means that the entity didn&#8217;t exist at that revision.</p>
</div>
<div class="paragraph">
<p>The "revision type" field can currently have three values: <code>0</code>, <code>1</code> and <code>2</code>, which means <code>ADD</code>, <code>MOD</code> and <code>DEL</code>, respectively.
A row with a revision of type <code>DEL</code> will only contain the id of the entity and no data (all fields <code>NULL</code>), as it only serves as a marker saying "this entity was deleted at that revision".</p>
</div>
<div class="paragraph">
<p>Additionally, there is a revision entity table which contains the information about the global revision.
By default the generated table is named <code>REVINFO</code> and contains just two columns: <code>ID</code> and <code>TIMESTAMP</code>.
A row is inserted into this table on each new revision, that is, on each commit of a transaction, which changes audited data.
The name of this table can be configured, the name of its columns as well as adding additional columns can be achieved as discussed in <a href="#envers-revisionlog">Revision Log</a>.</p>
</div>
<div class="admonitionblock note">
<table>
<tr>
<td class="icon">
<i class="fa icon-note" title="Note"></i>
</td>
<td class="content">
<div class="paragraph">
<p>While global revisions are a good way to provide correct auditing of relations, some people have pointed out that this may be a bottleneck in systems, where data is very often modified.</p>
</div>
<div class="paragraph">
<p>One viable solution is to introduce an option to have an entity "locally revisioned", that is revisions would be created for it independently.
This woulld not enable correct versioning of relations, but it would work without the <code>REVINFO</code> table.</p>
</div>
<div class="paragraph">
<p>Another possibility is to introduce a notion of "revisioning groups", which would group entities sharing the same revision numbering.
Each such group would have to consist of one or more strongly connected components belonging to the entity graph induced by relations between entities.</p>
</div>
<div class="paragraph">
<p>Your opinions on the subject are very welcome on the forum.</p>
</div>
</td>
</tr>
</table>
</div>
</div>
<div class="sect2">
<h3 id="envers-generateschema">Generating Envers schema with Hibernate hbm2ddl tool</h3>
<div class="paragraph">
<p>If you would like to generate the database schema file with Hibernate,
you simply need to use the hbm2ddl too.</p>
</div>
<div class="paragraph">
<p>This task will generate the definitions of all entities, both of which are audited by Envers and those which are not.</p>
</div>
<div class="paragraph">
<p>See the <a href="chapters/schema/Schema.html#schema-generation">Schema generation</a> chapter for more info.</p>
</div>
<div class="paragraph">
<p>For the following entities, Hibernate is going to generate the following database schema:</p>
</div>
<div id="envers-generateschema-example" class="exampleblock">
<div class="title">Example 45. Filtering a nested join relation using multiple predicates</div>
<div class="content">
<div class="listingblock">
<div class="content">
<pre class="prettyprint highlight"><code class="language-JAVA" data-lang="JAVA">@Audited
@Entity(name = "Customer")
public static class Customer {

    @Id
    private Long id;

    private String firstName;

    private String lastName;

    @Temporal( TemporalType.TIMESTAMP )
    @Column(name = "created_on")
    @CreationTimestamp
    private Date createdOn;

    @ManyToOne(fetch = FetchType.LAZY)
    private Address address;

    //Getters and setters omitted for brevity
}

@Audited
@Entity(name = "Address")
public static class Address {

    @Id
    private Long id;

    @ManyToOne(fetch = FetchType.LAZY)
    private Country country;

    private String city;

    private String street;

    private String streetNumber;

    //Getters and setters omitted for brevity
}

@Audited
@Entity(name = "Country")
public static class Country {

    @Id
    private Long id;

    private String name;

    //Getters and setters omitted for brevity
}</code></pre>
</div>
</div>
<div class="listingblock">
<div class="content">
<pre class="prettyprint highlight"><code class="language-SQL" data-lang="SQL">create table Address (
    id bigint not null,
    city varchar(255),
    street varchar(255),
    streetNumber varchar(255),
    country_id bigint,
    primary key (id)
)

create table Address_AUD (
    id bigint not null,
    REV integer not null,
    REVTYPE tinyint,
    REVEND integer,
    city varchar(255),
    street varchar(255),
    streetNumber varchar(255),
    country_id bigint,
    primary key (id, REV)
)

create table Country (
    id bigint not null,
    name varchar(255),
    primary key (id)
)

create table Country_AUD (
    id bigint not null,
    REV integer not null,
    REVTYPE tinyint,
    REVEND integer,
    name varchar(255),
    primary key (id, REV)
)

create table Customer (
    id bigint not null,
    created_on timestamp,
    firstName varchar(255),
    lastName varchar(255),
    address_id bigint,
    primary key (id)
)

create table Customer_AUD (
    id bigint not null,
    REV integer not null,
    REVTYPE tinyint,
    REVEND integer,
    created_on timestamp,
    firstName varchar(255),
    lastName varchar(255),
    address_id bigint,
    primary key (id, REV)
)

create table REVINFO (
    REV integer generated by default as identity,
    REVTSTMP bigint,
    primary key (REV)
)

alter table Address
add constraint FKpr4rl83u5fv832kdihl6w3kii
foreign key (country_id)
references Country

alter table Address_AUD
add constraint FKgwp5sek4pjb4awy66sp184hrv
foreign key (REV)
references REVINFO

alter table Address_AUD
add constraint FK52pqkpismfxg2b9tmwtncnk0d
foreign key (REVEND)
references REVINFO

alter table Country_AUD
add constraint FKrix4g8hm9ui6sut5sy86ujggr
foreign key (REV)
references REVINFO

alter table Country_AUD
add constraint FKpjeqmdccv22y1lbtswjb84ghi
foreign key (REVEND)
references REVINFO

alter table Customer
add constraint FKfok4ytcqy7lovuiilldbebpd9
foreign key (address_id)
references Address

alter table Customer_AUD
add constraint FK5ecvi1a0ykunrriib7j28vpdj
foreign key (REV)
references REVINFO

alter table Customer_AUD
add constraint FKqd4fy7ww1yy95wi4wtaonre3f
foreign key (REVEND)
references REVINFO</code></pre>
</div>
</div>
</div>
</div>
</div>
<div class="sect2">
<h3 id="envers-mappingexceptions">Mapping exceptions</h3>
<div class="sect3">
<h4 id="_what_isn_t_and_will_not_be_supported">What isn&#8217;t and will not be supported</h4>
<div class="paragraph">
<p>Bags are not supported because they can contain non-unique elements.
Persisting, a bag of `String`s violates the relational database principle that each table is a set of tuples.</p>
</div>
<div class="paragraph">
<p>In case of bags, however (which require a join table), if there is a duplicate element, the two tuples corresponding to the elements will be the same.
Hibernate allows this, however Envers (or more precisely: the database connector) will throw an exception when trying to persist two identical elements because of a unique constraint violation.</p>
</div>
<div class="paragraph">
<p>There are at least two ways out if you need bag semantics:</p>
</div>
<div class="olist arabic">
<ol class="arabic">
<li>
<p>use an indexed collection, with the <code>@javax.persistence.OrderColumn</code> annotation</p>
</li>
<li>
<p>provide a unique id for your elements with the <code>@CollectionId</code> annotation.</p>
</li>
</ol>
</div>
</div>
<div class="sect3">
<h4 id="_what_isn_t_and_em_will_em_be_supported">What isn&#8217;t and <em>will</em> be supported</h4>
<div class="olist arabic">
<ol class="arabic">
<li>
<p>Bag style collections with a <code>@CollectionId</code> identifier column (see <a href="https://hibernate.atlassian.net/browse/HHH-3950">HHH-3950</a>).</p>
</li>
</ol>
</div>
</div>
</div>
<div class="sect2">
<h3 id="__code_onetomany_code_with_code_joincolumn_code"><code>@OneToMany</code> with <code>@JoinColumn</code></h3>
<div class="paragraph">
<p>When a collection is mapped using these two annotations, Hibernate doesn&#8217;t generate a join table.
Envers, however, has to do this so that when you read the revisions in which the related entity has changed, you don&#8217;t get false results.</p>
</div>
<div class="paragraph">
<p>To be able to name the additional join table, there is a special annotation: <code>@AuditJoinTable</code>, which has similar semantics to JPA <code>@JoinTable</code>.</p>
</div>
<div class="paragraph">
<p>One special case are relations mapped with <code>@OneToMany</code> with <code>@JoinColumn</code> on the one side, and <code>@ManyToOne</code> and <code>@JoinColumn( insertable=false, updatable=false</code>) on the many side.
Such relations are, in fact, bidirectional, but the owning side is the collection.</p>
</div>
<div class="paragraph">
<p>To properly audit such relations with Envers, you can use the <code>@AuditMappedBy</code> annotation.
It enables you to specify the reverse property (using the <code>mappedBy</code> element).
In case of indexed collections, the index column must also be mapped in the referenced entity (using <code>@Column( insertable=false, updatable=false )</code>, and specified using <code>positionMappedBy</code>.
This annotation will affect only the way Envers works.
Please note that the annotation is experimental and may change in the future.</p>
</div>
</div>
<div class="sect2">
<h3 id="envers-partitioning">Advanced: Audit table partitioning</h3>

</div>
<div class="sect2">
<h3 id="envers-partitioning-benefits">Benefits of audit table partitioning</h3>
<div class="paragraph">
<p>Because audit tables tend to grow indefinitely, they can quickly become really large.
When the audit tables have grown to a certain limit (varying per RDBMS and/or operating system) it makes sense to start using table partitioning.
SQL table partitioning offers a lot of advantages including, but certainly not limited to:</p>
</div>
<div class="olist arabic">
<ol class="arabic">
<li>
<p>Improved query performance by selectively moving rows to various partitions (or even purging old rows)</p>
</li>
<li>
<p>Faster data loads, index creation, etc.</p>
</li>
</ol>
</div>
</div>
<div class="sect2">
<h3 id="envers-partitioning-columns">Suitable columns for audit table partitioning</h3>
<div class="paragraph">
<p>Generally, SQL tables must be partitioned on a column that exists within the table.
As a rule it makes sense to use either the <em>end revision</em> or the <em>end revision timestamp</em> column for partitioning of audit tables.</p>
</div>
<div class="admonitionblock note">
<table>
<tr>
<td class="icon">
<i class="fa icon-note" title="Note"></i>
</td>
<td class="content">
<div class="paragraph">
<p>End revision information is not available for the default <code>AuditStrategy</code>.</p>
</div>
<div class="paragraph">
<p>Therefore the following Envers configuration options are required:</p>
</div>
<div class="paragraph">
<p><code>org.hibernate.envers.audit_strategy</code> = <code>org.hibernate.envers.strategy.ValidityAuditStrategy</code></p>
</div>
<div class="paragraph">
<p><code>org.hibernate.envers.audit_strategy_validity_store_revend_timestamp</code> = <code>true</code></p>
</div>
<div class="paragraph">
<p>Optionally, you can also override the default values using following properties:</p>
</div>
<div class="paragraph">
<p><code>org.hibernate.envers.audit_strategy_validity_end_rev_field_name</code></p>
</div>
<div class="paragraph">
<p><code>org.hibernate.envers.audit_strategy_validity_revend_timestamp_field_name</code></p>
</div>
<div class="paragraph">
<p>For more information, see <a href="#envers-configuration">Configuration Properties</a>.</p>
</div>
</td>
</tr>
</table>
</div>
<div class="paragraph">
<p>The reason why the end revision information should be used for audit table partitioning is based on the assumption that audit tables should be partitioned on an 'increasing level of relevancy', like so:</p>
</div>
<div class="olist arabic">
<ol class="arabic">
<li>
<p>A couple of partitions with audit data that is not very (or no longer) relevant.
This can be stored on slow media, and perhaps even be purged eventually.</p>
</li>
<li>
<p>Some partitions for audit data that is potentially relevant.</p>
</li>
<li>
<p>One partition for audit data that is most likely to be relevant.
This should be stored on the fastest media, both for reading and writing.</p>
</li>
</ol>
</div>
</div>
<div class="sect2">
<h3 id="envers-partitioning-example">Audit table partitioning example</h3>
<div class="paragraph">
<p>In order to determine a suitable column for the 'increasing level of relevancy',
consider a simplified example of a salary registration for an unnamed agency.</p>
</div>
<div class="paragraph">
<p>Currently, the salary table contains the following rows for a certain person X:</p>
</div>
<table class="tableblock frame-all grid-all spread">
<caption class="title">Table 2. Salaries table</caption>
<colgroup>
<col style="width: 50%;">
<col style="width: 50%;">
</colgroup>
<thead>
<tr>
<th class="tableblock halign-left valign-top">Year</th>
<th class="tableblock halign-left valign-top">Salary (USD)</th>
</tr>
</thead>
<tbody>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">2006</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">3300</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">2007</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">3500</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">2008</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">4000</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">2009</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">4500</p></td>
</tr>
</tbody>
</table>
<div class="paragraph">
<p>The salary for the current fiscal year (2010) is unknown.
The agency requires that all changes in registered salaries for a fiscal year are recorded (i.e. an audit trail).
The rationale behind this is that decisions made at a certain date are based on the registered salary at that time.
And at any time it must be possible reproduce the reason why a certain decision was made at a certain date.</p>
</div>
<div class="paragraph">
<p>The following audit information is available, sorted on in order of occurrence:</p>
</div>
<table class="tableblock frame-all grid-all spread">
<caption class="title">Table 3. Salaries - audit table</caption>
<colgroup>
<col style="width: 20%;">
<col style="width: 20%;">
<col style="width: 20%;">
<col style="width: 20%;">
<col style="width: 20%;">
</colgroup>
<thead>
<tr>
<th class="tableblock halign-left valign-top">Year</th>
<th class="tableblock halign-left valign-top">Revision type</th>
<th class="tableblock halign-left valign-top">Revision timestamp</th>
<th class="tableblock halign-left valign-top">Salary (USD)</th>
<th class="tableblock halign-left valign-top">End revision timestamp</th>
</tr>
</thead>
<tbody>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">2006</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">ADD</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">2007-04-01</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">3300</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">null</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">2007</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">ADD</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">2008-04-01</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">35</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">2008-04-02</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">2007</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">MOD</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">2008-04-02</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">3500</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">null</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">2008</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">ADD</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">2009-04-01</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">3700</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">2009-07-01</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">2008</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">MOD</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">2009-07-01</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">4100</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">2010-02-01</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">2008</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">MOD</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">2010-02-01</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">4000</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">null</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">2009</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">ADD</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">2010-04-01</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">4500</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">null</p></td>
</tr>
</tbody>
</table>
</div>
<div class="sect2">
<h3 id="envers-partitioning-example-column">Determining a suitable partitioning column</h3>
<div class="paragraph">
<p>To partition this data, the <em>level of relevancy</em> must be defined. Consider the following:</p>
</div>
<div class="olist arabic">
<ol class="arabic">
<li>
<p>For fiscal year 2006 there is only one revision.
It has the oldest <em>revision timestamp</em> of all audit rows,
but should still be regarded as relevant because it&#8217;s the latest modification for this fiscal year in the salary table (its <em>end revision timestamp</em> is null).</p>
<div class="paragraph">
<p>Also, note that it would be very unfortunate if in 2011 there would be an update of the salary for fiscal year 2006 (which is possible in until at least 10 years after the fiscal year),
and the audit information would have been moved to a slow disk (based on the age of the <em>revision timestamp</em>).
Remember that, in this case, Envers will have to update the <em>end revision timestamp</em> of the most recent audit row.</p>
</div>
</li>
<li>
<p>There are two revisions in the salary of fiscal year 2007 which both have nearly the same <em>revision timestamp</em> and a different <em>end revision timestamp</em>.</p>
</li>
</ol>
</div>
<div class="paragraph">
<p>On first sight, it is evident that the first revision was a mistake and probably not relevant.
The only relevant revision for 2007 is the one with <em>end revision timestamp</em> null.</p>
</div>
<div class="paragraph">
<p>Based on the above, it is evident that only the <em>end revision timestamp</em> is suitable for audit table partitioning.
The <em>revision timestamp</em> is not suitable.</p>
</div>
</div>
<div class="sect2">
<h3 id="envers-partitioning-example-scheme">Determining a suitable partitioning scheme</h3>
<div class="paragraph">
<p>A possible partitioning scheme for the salary table would be as follows:</p>
</div>
<div class="dlist">
<dl>
<dt class="hdlist1"><em>end revision timestamp</em> year = 2008</dt>
<dd>
<p>This partition contains audit data that is not very (or no longer) relevant.</p>
</dd>
<dt class="hdlist1"><em>end revision timestamp</em> year = 2009</dt>
<dd>
<p>This partition contains audit data that is potentially relevant.</p>
</dd>
<dt class="hdlist1"><em>end revision timestamp</em> year &gt;= 2010 or null</dt>
<dd>
<p>This partition contains the most relevant audit data.</p>
</dd>
</dl>
</div>
<div class="paragraph">
<p>This partitioning scheme also covers the potential problem of the update of the <em>end revision timestamp</em>,
which occurs if a row in the audited table is modified.
Even though Envers will update the <em>end revision timestamp</em> of the audit row to the system date at the instant of modification,
the audit row will remain in the same partition (the 'extension bucket').</p>
</div>
<div class="paragraph">
<p>And sometime in 2011, the last partition (or 'extension bucket') is split into two new partitions:</p>
</div>
<div class="olist arabic">
<ol class="arabic">
<li>
<p><em>end revision timestamp</em> year = 2010:: This partition contains audit data that is potentially relevant (in 2011).</p>
</li>
<li>
<p><em>end revision timestamp</em> year &gt;= 2011 or null:: This partition contains the most interesting audit data and is the new 'extension bucket'.</p>
</li>
</ol>
</div>
</div>
<div class="sect2">
<h3 id="envers-links">Envers links</h3>
<div class="olist arabic">
<ol class="arabic">
<li>
<p><a href="http://hibernate.org">Hibernate main page</a></p>
</li>
<li>
<p><a href="http://community.jboss.org/en/envers?view=discussions">Forum</a></p>
</li>
<li>
<p><a href="https://hibernate.atlassian.net/">JIRA issue tracker</a> (when adding issues concerning Envers, be sure to select the "envers" component!)</p>
</li>
<li>
<p><a href="https://hibernate.hipchat.com/chat/room/1238636">HipChat channel</a></p>
</li>
<li>
<p><a href="https://community.jboss.org/wiki/EnversFAQ">FAQ</a></p>
</li>
</ol>
</div>
</div>
</div>
</div>
</div>
<div id="footer">
<div id="footer-text">
Last updated 2018-03-22 10:58:23 +00:00
</div>
</div>
</body>
</html>